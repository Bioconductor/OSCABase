---
output:
  html_document
bibliography: ../ref.bib
---

# Integrating Datasets

```{r setup, echo=FALSE, results="asis"}
source("workflows/knitr_options.R")
```

## Motivation

Large single-cell RNA sequencing (scRNA-seq) projects usually need to generate data across multiple batches due to logistical constraints.
However, the processing of different batches is often subject to uncontrollable differences, e.g., changes in operator, differences in reagent quality.
This results in systematic differences in the observed expression in cells from different batches, which we refer to as "batch effects".
Batch effects are problematic as they can be major drivers of heterogeneity in the data, masking the relevant biological differences and complicating interpretation of the results.

Computational correction of these effects is critical for eliminating batch-to-batch variation, allowing data across multiple batches to be combined for common downstream analysis.
However, existing methods based on linear models [@ritchie2015limma;@leek2012sva] assume that the composition of cell populations are either known or the same across batches.
To overcome these limitations, bespoke methods have been developed for batch correction of single-cell data [@haghverdi2018batch;@butler2018integrating;@lin2019scmerge] that do not require _a priori_ knowledge about the composition of the population.
This allows them to be used in workflows for exploratory analyses of scRNA-seq data where such knowledge is usually unavailable.

## Setting up the data

To demonstrate, we will use two separate 10X Genomics PBMC datasets generated in two different batches.
Each dataset was obtained from the `r Biocpkg("TENxPBMCData")` package and separately subjected to basic processing steps.
Separate processing prior to the batch correction step is more convenient, scalable and (on occasion) more reliable.
For example, outlier-based QC on the cells is more effective when performed within a batch (Chapter ???).
The same can also be said for trend fitting when modelling the mean-variance relationship (Section ???).

```{r, results='asis', echo=FALSE}
extractCached("workflows/tenx-batch-pbmc/3k", "clustering",
    c("pbmc3k", "dec3k"))
```

```{r}
pbmc3k
```

```{r, results='asis', echo=FALSE}
extractCached("workflows/tenx-batch-pbmc/4k", "clustering",
    c("pbmc4k", "dec4k"))
```

```{r}
pbmc4k
```

To prepare for the batch correction:

1. We subset all batches to the common "universe" of features.
In this case, it is straightforward as both batches use Ensembl gene annotation^[As we shall see later, this step can be much, much, much more painful. As is often said, biologists would rather share a toothbrush than nomenclature.].

    ```{r}
    universe <- intersect(rownames(pbmc3k), rownames(pbmc4k))
    length(universe)
    ```

2. We rescale each batch to adjust for differences in sequencing depth between batches.
The `multiBatchNorm()` function recomputes log-normalized expression values after adjusting the size factors for systematic differences in coverage between `SingleCellExperiment` objects.
(Size factors only remove biases between cells _within_ a single batch.)
This improves the quality of the correction by removing one aspect of the technical differences between batches.

    ```{r}
    library(batchelor)
    rescaled <- multiBatchNorm(pbmc3k[universe,], pbmc4k[universe,])
    pbmc3k <- rescaled[[1]]
    pbmc4k <- rescaled[[2]]
    ```

3. We obtain a single set of features for batch correction by computing the average biological component across all batches.
We use the average as it is responsive to batch-specific HVGs but does not put too much weight on biological components that are small and positive in only a few batches.
We then take all genes with positive average components to ensure that we retain as much interesting biology as possible.
However, the other feature selection strategies described in Chapter ??? are also reasonable.

    ```{r}
    mean.bio <- (dec3k[universe,"bio"] + dec4k[universe,"bio"])/2
    chosen <- universe[mean.bio > 0]
    length(chosen)
    ```

## Diagnosing batch effects

Before we actually perform any correction, it is worth examining whether there is any batch effect in this dataset.
We combine the two `SingleCellExperiment`s and perform a PCA on the log-expression values for the selected genes.

```{r}
# Synchronizing the metadata for cbind()ing.
rowData(pbmc3k) <- rowData(pbmc4k)
pbmc3k$batch <- "3k"
pbmc4k$batch <- "4k"
combined <- cbind(pbmc3k, pbmc4k)

library(scater)
set.seed(0010101010)
combined <- runPCA(combined, subset_row=chosen, 
    BSPARAM=BiocSingular::RandomParam())
```

We use graph-based clustering on the components to obtain a summary of the population structure.
As our two PBMC populations should be replicates, each cluster should ideally consist of cells from both batches.
However, we instead see clusters that are comprised of cells from a single batch.
This indicates that cells of the same type are artificially separated due to technical differences between batches.

```{r}
library(scran)
snn.gr <- buildSNNGraph(combined, use.dimred="PCA")
clusters <- igraph::cluster_walktrap(snn.gr)$membership
tab <- table(Cluster=clusters, Batch=combined$batch)
tab
```

```{r, echo=FALSE}
stopifnot(any(tab==0)) # Check the text above was correct.
```

We can also visualize the corrected coordinates using a $t$-SNE plot (Figure \@ref(fig:tsne-pbmc-uncorrected)).
The strong separation between cells from different batches is consistent with the clustering results.

```{r tsne-pbmc-uncorrected, fig.cap="$t$-SNE plot of the PBMC datasets without any batch correction. Each point is a cell that is colored according to its batch of origin."}
combined <- runTSNE(combined, dimred="PCA")
plotTSNE(combined, colour_by="batch")
```

Of course, the other explanation for batch-specific clusters is that there are cell types that are unique to each batch.
The degree of intermingling of cells from different batches is not an effective diagnostic when the batches involved might actually contain unique cell subpopulations (which is not a consideration in the PBMC dataset, but the same cannot be said in general).
If a cluster only contains cells from a single batch, one can always debate whether that is caused by a failure of the correction method or if there is truly a batch-specific subpopulation.
For example, do batch-specific metabolic or differentiation states represent distinct subpopulations? 
Or should they be merged together?
We will not attempt to answer this here, only noting that each batch correction algorithm will make different (and possibly inappropriate) decisions on what constitutes "shared" and "unique" populations.

## Linear regression

### Overview

Batch effects in bulk RNA sequencing studies are commonly removed with linear modelling.
This involves fitting a linear model to each gene's expression profile, setting the undesirable batch term to zero and recomputing the observations _sans_ the batch effect, yielding a set of corrected expression values for downstream analyses.
Linear modelling is the basis of the `removeBatchEffect()` function from the `r Biocpkg("limma")` package [@ritchie2015limma] as well the `comBat()` function from the `r Biocpkg("sva")` package [@leek2012sva].

The typical assumption of this approach is that the composition of cell populations is the same across batches.
This is a relatively strong assumption in scRNA-seq contexts as batches derived from different individuals will naturally exhibit variation in cell type abundances.
However, it may be applicable for batches that are technical replicates generated from the same population of cells.
Linear modelling can also accommodate situations where the composition is known _a priori_ by including the cell type as a factor in the linear model, but this situation is even less common^[If I already knew the type and state of each cell, why would I waste money sequencing the bloody things?].

We use the `rescaleBatches()` function from the `r Biocpkg("batchelor")` package to remove the batch effect.
This is roughly equivalent to applying a linear regression to the log-expression values per gene, with some adjustments to improve performance and efficiency.
For each gene, the mean expression in each batch is scaled down until it is equal to the lowest mean across all batches.
We deliberately choose to scale all expression values down as this mitigates differences in variance when batches lie at different positions on the mean-variance trend.
(Specifically, the shrinkage effect of the pseudo-count is greater for smaller counts, suppressing any differences in variance across batches.)
An additional feature of `rescaleBatches()` is that it will preserve sparsity in the input matrix for greater efficiency, whereas other methods like `removeBatchEffect()` will always return a dense matrix.

```{r}
# TODO: modify rescaleBatches() to support known groups.
# 'block' specifies the plate of origin.
library(batchelor)
rescaled <- rescaleBatches(pbmc3k, pbmc4k)
rescaled
```

### Checking diagnostics

After clustering, we observe that each batch contributes cells to each cluster.
This is consistent with the removal of the batch effect, given that both PBMC populations should contain the same cell types.

```{r}
set.seed(1010101010)
rescaled <- runPCA(rescaled, subset_row=chosen,
    BSPARAM=BiocSingular::IrlbaParam(), exprs_values="corrected")

snn.gr <- buildSNNGraph(rescaled, use.dimred="PCA")
clusters <- igraph::cluster_walktrap(snn.gr)$membership
tab <- table(Cluster=clusters, Batch=rescaled$batch)
tab
```

```{r, echo=FALSE}
stopifnot(all(tab>0)) # Check the text above was correct.
```

This conclusion is supported by the apparent mixing of cells from different batches in Figure \@ref(fig:tsne-pbmc-rescaled).

```{r tsne-pbmc-rescaled, fig.asp=0.5, fig.cap="$t$-SNE plot of the PBMC datasets after correction with `rescaleBatches()`. Each point represents a cell and is colored according to the batch of origin."}
rescaled <- runTSNE(rescaled, dimred="PCA")
plotTSNE(rescaled, colour_by="batch")
```

Another useful diagnostic is to compare the clustering within each batch to the clustering of the merged data.
Ideally, we should see a many-to-1 mapping where the across-batch clustering is nested inside the within-batch clusterings.
(That is, the vast majority of entries of the `table()`s below should be zero.)
This indicates that any within-batch structure was preserved during batch correction while acknowledging that greater resolution is possible with more cells.
In practice, more discrepancies can be expected even when the correction is flawless, due to the presence of neighboring clusters that were arbitrarily separated in the first place.

```{r}
# For the first batch.
table(New=clusters[rescaled$batch==1], Old=pbmc3k$cluster)

# For the second batch.
table(New=clusters[rescaled$batch==2], Old=pbmc4k$cluster)
```

### Application to a pancreas dataset

In this example, it is likely that both batches were generated from the same underlying population of cells.
When batches have similar cell type composition, `rescaleBatches()` and related methods provide an accurate and simple correction.
However, this is not often the case, as we will demonstrate with two human pancreas CEL-seq datasets [@muraro2016singlecell;@grun2016denovo].

```{r, results='asis', echo=FALSE}
extractCached("workflows/grun-pancreas", "variance-modelling",
    c("sce.grun", "dec.grun"))
```

```{r}
sce.grun
```

```{r, results='asis', echo=FALSE}
extractCached("workflows/muraro-pancreas", "variance-modelling",
    c("sce.muraro", "dec.muraro"))
```

```{r}
sce.muraro
```

We subset both batches to their common universe of genes;
adjust their scaling to equalize sequencing coverage (not really necessary in this case, as the coverage is already similar, but we will do so anyway for consistency);
and select those genes with positive average biological components for further use.

```{r}
universe <- intersect(rownames(sce.grun), rownames(sce.muraro))
universe <- universe[!grepl("^ERCC", universe)]

normed.pancreas <- multiBatchNorm(sce.grun[universe,], sce.muraro[universe,])
sce.grun <- normed.pancreas[[1]]
sce.muraro <- normed.pancreas[[2]]

mean.bio <- (dec.grun[universe,"bio"] + dec.muraro[universe,"bio"])/2
chosen.genes <- universe[mean.bio > 0]
```

We observe that `rescaleBatches()` is unable to align cells from different batches in Figure \@ref(fig:tsne-pancreas-rescaled).
This is attributable to differences in population composition between batches, with additional complications from non-linearities in the batch effect, e.g., when the magnitude or direction of the batch effect differs between cell types.

```{r tsne-pancreas-rescaled, fig.asp=0.5, fig.cap="$t$-SNE plot of the pancreas datasets after correction with `rescaleBatches()`. Each point represents a cell and is colored according to the batch of origin."}
rescaled.pancreas <- rescaleBatches(sce.grun, sce.muraro)
rescaled.pancreas <- runPCA(rescaled.pancreas, subset_row=chosen.genes,
    BSPARAM=BiocSingular::IrlbaParam(), exprs_values="corrected")

rescaled.pancreas <- runTSNE(rescaled.pancreas, dimred="PCA")
plotTSNE(rescaled.pancreas, colour_by="batch")
```

## Performing MNN correction

### Application to the PBMC data

Consider a cell $a$ in batch $A$, and identify the cells in batch $B$ that are nearest neighbours to $a$ in the expression space defined by the selected features.
Repeat this for a cell $b$ in batch $B$, identifying its nearest neighbours in $A$.
Mutual nearest neighbours are pairs of cells from different batches that belong in each other's set of nearest neighbours.
The reasoning is that MNN pairs represent cells from the same biological state prior to the application of a batch effect - see @haghverdi2018batch for full theoretical details.
Thus, the difference between cells in MNN pairs can be used as an estimate of the batch effect, the subtraction of which can yield batch-corrected values.

The `r Biocpkg("batchelor")` package provides an implementation of the MNN approach via the `fastMNN()` function.
(Unlike the MNN method described by @haghverdi2018batch, the `fastMNN()` function performs PCA to reduce the dimensions beforehand and speed up the downstream neighbor detection steps.)
We apply it to our two PBMC batches to remove the batch effect across the highly variable genes in `chosen`.
To reduce computational work and technical noise, all cells in all batches are projected into the low-dimensional space defined by the top `d` principal components.
Identification of MNNs and calculation of correction vectors are then performed in this low-dimensional space.

```{r}
# Using randomized SVD here, as this is faster than 
# irlba for file-backed matrices.
set.seed(1000101001)
mnn.out <- fastMNN(pbmc3k, pbmc4k, d=50, k=20,
    BSPARAM=BiocSingular::RandomParam(deferred=TRUE))
```

The function returns a `SingleCellExperiment` object containing corrected values for downstream analyses like clustering or visualization.
Each column of `mnn.out` corresponds to a cell in one of the batches, while each row corresponds to an input gene in `chosen`.

```{r}
mnn.out
```

The `batch` field in the column metadata contains a vector specifying the batch of origin of each cell. 

```{r}
head(mnn.out$batch) 
```

The `corrected` matrix in the `reducedDims` slot contains the low-dimensional corrected coordinates for all cells, which we will use in place of the PCs in our downstream analyses.

```{r}
dim(reducedDim(mnn.out, "corrected"))
```

The `k` parameter is the most important and specifies the number of nearest neighbours to consider when defining MNN pairs.
This should be interpreted as the minimum frequency of any shared cell type or state in each batch.

- Larger values will improve the precision of the correction by increasing the number of MNN pairs.
- Larger `k` provides some robustness to violations of the assumption that the batch vector is orthogonal to the biological subspace [@haghverdi2018batch], by allowing the neighbour search to ignore biological variation in each batch to identify the correct MNN pairs.
- However, larger `k` can also reduce accuracy by allowing incorrect MNN pairs to form between cells of different types.

We suggest starting with the default `k` and increasing it if one is confident that the same cell types are not adequately merged across batches.
This is better than starting with a large `k` as incorrect merging is much harder to diagnose than insufficient merging.

### Correction diagnostics 

### Clustering and visualization

We use graph-based clustering on the low-dimensional corrected coordinates to obtain a partitioning of the cells that serves as a proxy for the population structure.
If the batch effect is successfully corrected, clusters corresponding to shared cell types or states should contain cells from both batches.

```{r}
library(scran)
snn.gr <- buildSNNGraph(mnn.out, use.dimred="corrected")
clusters <- igraph::cluster_walktrap(snn.gr)$membership
tab <- table(Cluster=clusters, Batch=mnn.out$batch)
tab
```

```{r, echo=FALSE}
stopifnot(all(tab>0)) # Check the text above was correct.
```

We can also visualize the corrected coordinates using a $t$-SNE plot (Figure \@ref(fig:tsne-pbmc-corrected)).
The presence of visual clusters containing cells from both batches provides a comforting illusion that the correction was successful.

```{r tsne-pbmc-corrected, fig.cap="$t$-SNE plot of the PBMC datasets after MNN correction. Each point is a cell that is colored according to its batch of origin."}
library(scater)
set.seed(0010101010)
mnn.out <- runTSNE(mnn.out, use_dimred="corrected")

mnn.out$batch <- factor(mnn.out$batch)
plotTSNE(mnn.out, colour_by="batch")
```

We could also compare to the clustering within each batch, but we will skip that here for the sake of brevity.

#### Percentage of variance lost

For `fastMNN()`, one useful diagnostic is the proportion of variance within each batch that is lost during MNN correction.
Specifically, this refers to the within-batch variance that is removed during orthogonalization with respect to the average correction vector at each merge step. 
This is returned via the `lost.var` field in the metadata of `mnn.out`, which contains a matrix of the variance lost in each batch (column) at each merge step (row).

```{r}
metadata(mnn.out)$merge.info$lost.var
```

Large proportions of lost variance suggest that correction is removing genuine biological heterogeneity.
This would occur due to violations of the assumption of orthogonality between the batch effect and the biological subspace [@haghverdi2018batch].
In this case, the proportion of lost variance is small, indicating that non-orthogonality is not a major concern.

### Application to the pancreas data

As the PBMC dataset can already be corrected by linear regression, it is helpful to examine another situation where the sophistication of the MNN approach becomes necessary.
Here, we use `fastMNN()` to merge together the two human pancreas datasets described earlier.
Clustering on the merged datasets yields fewer batch-specific clusters, which is recapitulated as greater intermingling between batches in Figure \@ref(fig:tsne-pancreas-mnn).
This improvement over Figure \@ref(fig:tsne-pancreas-rescaled) represents the ability of `fastMNN()` to adapt to more complex situations involving differences in population composition between batches.

```{r tsne-pancreas-mnn, fig.asp=0.5, fig.cap="$t$-SNE plot of the pancreas datasets after correction with `fastMNN()`. Each point represents a cell and is colored according to the batch of origin."}
mnn.pancreas <- fastMNN(sce.grun, sce.muraro, subset.row=chosen.genes)

snn.gr <- buildSNNGraph(mnn.pancreas, use.dimred="corrected")
clusters <- igraph::cluster_walktrap(snn.gr)$membership
tab <- table(Cluster=clusters, Batch=mnn.pancreas$batch)
tab

mnn.pancreas <- runTSNE(mnn.pancreas, dimred="corrected")
plotTSNE(mnn.pancreas, colour_by="batch")
```

## Using the corrected values

The greatest value of batch correction lies in facilitating cell-based analysis of population heterogeneity in a consistent manner across batches.
Cluster 1 in batch A is the same as cluster 1 in batch B when the clustering is performed on the merged data.
There is no need to identify mappings between separate clusterings, which might not even be possible when the clusters are not well-separated.
The burden of interpretation is consolidated by generating a single set of clusters for all batches, rather than requiring separate examination of each batch's clusters.
Another benefit is that the available number of cells is increased when all batches are combined, which allows for greater resolution of population structure in downstream analyses^[And a nice $t$-SNE plot for Figure 1. Hey, those atlas papers almost write themselves!].
We previously demonstrated the application of clustering methods to the batch-corrected data, but the same principles apply for other analyses like trajectory reconstruction. 

At this point, it is also tempting to use the batch-corrected values for gene-based analyses like DE-based marker gene detection. 
This is not generally recommended as an arbitrary correction algorithm is not obliged to preserve the magnitude (or even direction) of differences in per-gene expression when attempting to align multiple batches.
For example, cosine normalization in `fastMNN()` shrinks the magnitude of the expression values so that any subsequent log-fold change calculations are meaningless.
Rather, it is preferable to perform DE analyses using the uncorrected expression values with blocking on the batch, as discussed i Chapter ???.
This strategy is based on the expectation that any genuine DE between clusters should still be present in a within-batch comparison where batch effects are absent.
It penalizes genes that exhibit inconsistent DE across batches, thus protecting against misleading conclusions when a population in one batch is aligned to a similar-but-not-identical population in another batch.

## Session Info {-}

```{r sessionInfo, echo=FALSE, results='asis'}
prettySessionInfo()
```

## References {-}
