# Human Cell Atlas bone marrow dataset

```{r setup, echo=FALSE, results="asis"}
library(OSCAUtils)
chapterPreamble(use_cache = TRUE)
```

## Introduction

Here, we use an example dataset from the [Human Cell Atlas immune cell profiling project on bone marrow](https://preview.data.humancellatlas.org), which contains scRNA-seq data for 380,000 cells generated using the 10X Genomics technology.
This is a fairly big dataset that represents a good use case for the techniques in Chapter \@ref(dealing-with-big-data).

## Analysis code

### Data loading

This dataset is loaded via the `r Biocpkg("HCAData")` package, which provides a ready-to-use `SingleCellExperiment` object. 

```{r loading}
library(HCAData)
sce.bone <- HCAData('ica_bone_marrow')
sce.bone$Donor <- sub("_.*", "", sce.bone$Barcode)
```

### Gene annotation

We use symbols in place of IDs for easier interpretation later.

```{r gene-annotation}
library(EnsDb.Hsapiens.v86)
rowData(sce.bone)$Chr <- mapIds(EnsDb.Hsapiens.v86, keys=rownames(sce.bone),
    column="SEQNAME", keytype="GENEID")

library(scater)
rownames(sce.bone) <- uniquifyFeatureNames(rowData(sce.bone)$ID,
    names = rowData(sce.bone)$Symbol)
```

### Quality control

Cell calling was not performed (see [here](https://s3.amazonaws.com/preview-ica-expression-data/Brief+ICA+Read+Me.pdf)) so we will perform QC using all metrics and block on the donor of origin during outlier detection.
We perform the calculation across multiple cores to speed things up.

```{r quality-control}
library(BiocParallel)
sce.bone <- addPerCellQC(sce.bone, subsets=list(
    Mito=which(rowData(sce.bone)$Chr=="MT")),
    BPPARAM=MulticoreParam())
unfiltered <- sce.bone

qc <- quickPerCellQC(colData(sce.bone), batch=sce.bone$Donor,
    percent_subset="subsets_Mito_percent")
sce.bone <- sce.bone[,!qc$discard]
```

### Normalization

For a minor speed-up, we piggy-back off the already-computed library sizes to avoid having to re-compute them as size factors.

```{r normalization}
sce.bone <- logNormCounts(sce.bone, size_factors=sce.bone$sum)
```

### Variance modelling

Blocking on the donor to mitigate batch effects during HVG selection.

```{r variance-modelling}
library(scran)
dec.bone <- modelGeneVar(sce.bone, block=sce.bone$Donor,
    BPPARAM=MulticoreParam())
top.bone <- getTopHVGs(dec.bone, n=2000)
```

### Data integration

Here we use multiple cores, randomized SVD and approximate nearest-neighbor detection to speed up this step.

```{r integration}
library(batchelor)
library(BiocNeighbors)

set.seed(1010001)
merged.bone <- fastMNN(sce.bone, batch = sce.bone$Donor, subset.row = top.bone,
     BSPARAM=BiocSingular::RandomParam(deferred = TRUE),
     BNPARAM=AnnoyParam(),
     BPPARAM=MulticoreParam())

reducedDim(sce.bone, 'MNN') <- reducedDim(merged.bone, 'corrected')
```

### Dimensionality reduction

We set `external_neighbors=TRUE` to replace the internal NN search in the UMAP implementation with our parallelized approximate search.

```{r dimensionality-reduction}
set.seed(01010100)
sce.bone <- runUMAP(sce.bone, dimred="MNN",
    external_neighbors=TRUE, 
    BNPARAM=AnnoyParam(),
    BPPARAM=MulticoreParam())
```

### Clustering

Graph-based clustering generates an excessively large intermediate graph, so we will switch to $k$-means instead.
Some parameter fiddling is required to improve convergence with such a large number of points.

```{r clustering}
set.seed(1000)
kout.bone <- kmeans(reducedDim(sce.bone, "MNN"), 
    centers=25, iter.max=1000, algorithm="MacQueen") 
sce.bone$cluster <- factor(kout.bone$cluster)
```

### Differential expression

We identify marker genes for each cluster while blocking on the donor.

```{r differential-expression}
markers.bone <- findMarkers(sce.bone, sce.bone$cluster,
    block = sce.bone$Donor, 
    direction = 'up', lfc = 1,
    BPPARAM = MulticoreParam())
```

## Results

### Quality control statistics

```{r, fig.wide=TRUE}
unfiltered$discard <- qc$discard
gridExtra::grid.arrange(
    plotColData(unfiltered, x="Donor", y="sum", colour_by="discard") +
        scale_y_log10() + ggtitle("Total count"),
    plotColData(unfiltered, x="Donor", y="detected", colour_by="discard") +
        scale_y_log10() + ggtitle("Detected features"),
    plotColData(unfiltered, x="Donor", y="subsets_Mito_percent",
        colour_by="discard") + ggtitle("Mito percent"),
    ncol=2
)
```

### Normalization

```{r}
summary(sizeFactors(sce.bone))
```

### Variance modelling

```{r, fig.asp=2, fig.height=10}
par(mfrow=c(4,2))
blocked.stats <- dec.bone$per.block
for (i in colnames(blocked.stats)) {
    current <- blocked.stats[[i]]
    plot(current$mean, current$total, main=i, pch=16, cex=0.5,
        xlab="Mean of log-expression", ylab="Variance of log-expression")
    curfit <- metadata(current)
    curve(curfit$trend(x), col='dodgerblue', add=TRUE, lwd=2)
}
```

### Data integration

```{r}
metadata(merged.bone)$merge.info$lost.var
```

### Clustering

```{r}
table(Cluster=sce.bone$cluster, Donor=sce.bone$Donor)
```

```{r}
plotUMAP(sce.bone, colour_by="cluster")

# TODO: add scrambling option in scater's plotting functions.
scrambled <- sample(ncol(sce.bone))
plotUMAP(sce.bone[,scrambled], colour_by="Donor")
```

## Miscellaneous

ROB TO FIX.

```{r annotation, eval=FALSE}
## Annotation ----------------------------------------------
## Get mappings of ENTREZID to Symbol
library(org.Hs.eg.db)
keys_entrez <- keys(org.Hs.eg.db, 'ENTREZID')
mapping_es <- AnnotationDbi::select(org.Hs.eg.db,
                                    keys = keys_entrez,
                                    columns = c('ENTREZID', 'SYMBOL'),
                                    keytype = 'ENTREZID')
mapping_es$ENTREZID <- as.integer(mapping_es$ENTREZID)
## Get pathways of interest - convert to list with symbol
## devtools::install_github('stephenturner/msigdf')
library(msigdf)
library(dplyr)
mdb <- dplyr::inner_join(msigdf.human, mapping_es,
                         by = c('entrez' = 'ENTREZID')) %>%
    dplyr::filter(collection == 'c7') %>%
    dplyr::select(-collection, -entrez) %>%
    dplyr::group_nest(geneset)
pathways <- purrr::map(mdb$data, function(x) {
    as.character(x$SYMBOL)
})
names(pathways) <- mdb$geneset
## Get stats based on markers search - compare clusters 3 vs 2
stats <- markers_any[[3]]$logFC.2
names(stats) <- rownames(markers_any[[3]])
## Run fast gene set enrichment analysis (see plot at bottom)
library(fgsea)
fgseaRes <- fgsea(pathways = pathways, 
                  stats = stats,
                  minSize = 15,
                  maxSize = 500,
                  nperm = 10000)
```

```{r trajectory, eval=FALSE}
## Trajectory Analysis -------------------------------------
library(slingshot)
slc <- slingshot(sce[, sce$clusters %in% c(3, 5, 9)],
                 clusterLabels = 'clusters',
                 reducedDim = 'UMAP')
```

```{r}
## Interactive Exploration ---------------------------------
## library(iSEE)
## iSEE(sce) ## not run; opens a web browser GUI
```

## Visualizations

```{r viz-trajectory, eval=FALSE}
## Trajectory analysis -------------------------------------
## Slingshot trajectory plot
library(RColorBrewer)
colors <- colorRampPalette(brewer.pal(11, 'Spectral')[-6])(100)
plotcol <- colors[cut(slc$slingPseudotime_1, breaks = 100)]
plot(reducedDims(slc)$UMAP, col = plotcol, pch=16, asp = 1)
lines(SlingshotDataSet(slc), lwd = 2, col = 'black')
```

```{r viz-umap, eval=FALSE}
## UMAP based plots ----------------------------------------
## UMAP (no colours)
plotUMAP(sce)
## Pre vs post batch correction
tmp <- runPCA(sce,
              BSPARAM = BiocSingular::IrlbaParam(),
              BPPARAM = BiocParallel::MulticoreParam())
tmp <- runUMAP(tmp,
               BNPARAM = BiocNeighbors::AnnoyParam(),
               BPPARAM = BiocParallel::MulticoreParam(),
               ## unnecessary options, only used to make a pretty graph
               min_dist = 0.5, repulsion_strength = 0.25,
               spread = 0.7,
               n_neighbors = 15)
p0 <- plotUMAP(tmp, colour_by = 'Donor')
p1 <- plotUMAP(sce, colour_by = 'Donor')
patchwork::wrap_plots(p0, p1, nrow = 2)
## Gene expression on UMAP plots
p2 <- plotUMAP(sce, colour_by = 'CD3E')
p3 <- plotUMAP(sce, colour_by = 'CD79A')
p4 <- plotUMAP(sce, colour_by = 'LYZ')
p5 <- plotUMAP(sce, colour_by = 'NKG7')
patchwork::wrap_plots(p2, p3, p4, p5, nrow = 2)
## Clusters on UMAP
plotUMAP(sce, colour_by = 'clusters', text_by = 'clusters')
```

```{r viz-gene-exp, eval=FALSE}
## Gene expression plots -----------------------------------
## Heatmap: Top global markers per cluster
top_markers <- lapply(markers, function(x) {
    rownames(x)[1:20]
})
top_markers <- sort(unique(unlist(top_markers)))
top_markers <- top_markers[!grepl('MT-|^RP', top_markers)]
set.seed(1234)
plotHeatmap(sce[, sample(ncol(sce), 5000)],
            features = top_markers,
            color = viridis::viridis(101, option = 'A'),
##            symmetric = TRUE, zlim = c(-5, 5),
            colour_columns_by = 'clusters',
            clustering_method = 'ward.D2',
            show_colnames = FALSE,
            fontsize_row = 6
            )
## Volcano plot
marker_tbl_3 <- as.data.frame(markers_any[[3]])
marker_tbl_3 %>%
    ggplot(aes(x = logFC.2, y = -log10(FDR))) +
    geom_point() +
    geom_vline(xintercept = c(-log(1.5), log(1.5)), linetype = 'dashed') +
    theme_classic() +
    coord_cartesian(xlim = c(-2, 2), expand = FALSE)
```

```{r viz-gsea, eval=FALSE}
## Gene set enrichment -------------------------------------
## Plot multiple pathways enrichment plots
topPathwaysUp <- fgseaRes[ES > 0][head(order(pval), n=10), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(pval), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(pathways[topPathways], stats,
              fgseaRes, 
              gseaParam = 0.5)
## Traditional GSEA plot
plotEnrichment(pathways[["GSE29618_MONOCYTE_VS_PDC_UP"]],
               stats)
```


## Session Info {-}

```{r sessionInfo, echo=FALSE, results='asis'}
prettySessionInfo()
```
