# Human Cell Atlas bone marrow dataset

```{r setup, echo=FALSE, results="asis"}
library(OSCAUtils)
chapterPreamble(use_cache = TRUE)
```

## Introduction

Here, we use an example dataset from the [Human Cell Atlas immune cell profiling project on bone marrow](https://preview.data.humancellatlas.org), which contains scRNA-seq data for 380,000 cells generated using the 10X Genomics technology.
This is a fairly big dataset that represents a good use case for the techniques in Chapter \@ref(dealing-with-big-data).

## Analysis code

### Data loading

This dataset is loaded via the `r Biocpkg("HCAData")` package, which provides a ready-to-use `SingleCellExperiment` object. 

```{r loading}
library(HCAData)
sce.bone <- HCAData('ica_bone_marrow')
sce.bone$Donor <- sub("_.*", "", sce.bone$Barcode)
```

```{r testsubsample, eval=FALSE, echo=FALSE, include=FALSE}
set.seed(1234)
sce.bone <- sce.bone[, sample(ncol(sce.bone), 1000)]
```

### Gene annotation

We use symbols in place of IDs for easier interpretation later.

```{r gene-annotation}
library(EnsDb.Hsapiens.v86)
rowData(sce.bone)$Chr <- mapIds(EnsDb.Hsapiens.v86, keys=rownames(sce.bone),
    column="SEQNAME", keytype="GENEID")

library(scater)
rownames(sce.bone) <- uniquifyFeatureNames(rowData(sce.bone)$ID,
    names = rowData(sce.bone)$Symbol)
```

### Quality control

Cell calling was not performed (see [here](https://s3.amazonaws.com/preview-ica-expression-data/Brief+ICA+Read+Me.pdf)) so we will perform QC using all metrics and block on the donor of origin during outlier detection.
We perform the calculation across multiple cores to speed things up.

```{r quality-control}
library(BiocParallel)
sce.bone <- addPerCellQC(sce.bone, subsets=list(
    Mito=which(rowData(sce.bone)$Chr=="MT")),
    BPPARAM=MulticoreParam())
unfiltered <- sce.bone

qc <- quickPerCellQC(colData(sce.bone), batch=sce.bone$Donor,
    percent_subset="subsets_Mito_percent")
sce.bone <- sce.bone[,!qc$discard]
```

### Normalization

For a minor speed-up, we piggy-back off the already-computed library sizes to avoid having to re-compute them as size factors.

```{r normalization}
sce.bone <- logNormCounts(sce.bone, size_factors=sce.bone$sum)
```

### Variance modelling

Blocking on the donor to mitigate batch effects during HVG selection.

```{r variance-modelling}
library(scran)
dec.bone <- modelGeneVar(sce.bone, block=sce.bone$Donor,
    BPPARAM=MulticoreParam())
top.bone <- getTopHVGs(dec.bone, n=2000)
```

### Data integration

Here we use multiple cores, randomized SVD and approximate nearest-neighbor detection to speed up this step.

```{r integration}
library(batchelor)
library(BiocNeighbors)

set.seed(1010001)
merged.bone <- fastMNN(sce.bone, batch = sce.bone$Donor, subset.row = top.bone,
     BSPARAM=BiocSingular::RandomParam(deferred = TRUE),
     BNPARAM=AnnoyParam(),
     BPPARAM=MulticoreParam())

reducedDim(sce.bone, 'MNN') <- reducedDim(merged.bone, 'corrected')
```

### Dimensionality reduction

We set `external_neighbors=TRUE` to replace the internal NN search in the UMAP implementation with our parallelized approximate search.

```{r dimensionality-reduction}
set.seed(01010100)
sce.bone <- runUMAP(sce.bone, dimred="MNN",
    external_neighbors=TRUE, 
    BNPARAM=AnnoyParam(),
    BPPARAM=MulticoreParam())
```

### Clustering

Graph-based clustering generates an excessively large intermediate graph, so we will switch to $k$-means instead.
Some parameter fiddling is required to improve convergence with such a large number of points.

```{r clustering}
set.seed(1000)
kout.bone <- kmeans(reducedDim(sce.bone, "MNN"), 
    centers=25, iter.max=1000, algorithm="MacQueen") 
sce.bone$cluster <- factor(kout.bone$cluster)
```

### Differential expression

We identify marker genes for each cluster while blocking on the donor.

```{r differential-expression}
markers.bone <- findMarkers(sce.bone, sce.bone$cluster,
    block = sce.bone$Donor, 
    direction = 'up', lfc = 1,
    BPPARAM = MulticoreParam())
```

## Results

### Quality control statistics

```{r, fig.wide=TRUE}
unfiltered$discard <- qc$discard
gridExtra::grid.arrange(
    plotColData(unfiltered, x="Donor", y="sum", colour_by="discard") +
        scale_y_log10() + ggtitle("Total count"),
    plotColData(unfiltered, x="Donor", y="detected", colour_by="discard") +
        scale_y_log10() + ggtitle("Detected features"),
    plotColData(unfiltered, x="Donor", y="subsets_Mito_percent",
        colour_by="discard") + ggtitle("Mito percent"),
    ncol=2
)
```

### Normalization

```{r}
summary(sizeFactors(sce.bone))
```

### Variance modelling

```{r, fig.asp=2, fig.height=10}
par(mfrow=c(4,2))
blocked.stats <- dec.bone$per.block
for (i in colnames(blocked.stats)) {
    current <- blocked.stats[[i]]
    plot(current$mean, current$total, main=i, pch=16, cex=0.5,
        xlab="Mean of log-expression", ylab="Variance of log-expression")
    curfit <- metadata(current)
    curve(curfit$trend(x), col='dodgerblue', add=TRUE, lwd=2)
}
```

### Data integration

```{r}
metadata(merged.bone)$merge.info$lost.var
```

### Clustering

```{r}
table(Cluster=sce.bone$cluster, Donor=sce.bone$Donor)
```

```{r}
plotUMAP(sce.bone, colour_by="cluster")

# TODO: add scrambling option in scater's plotting functions.
scrambled <- sample(ncol(sce.bone))
plotUMAP(sce.bone[,scrambled], colour_by="Donor")
```



## Downstream Analysis

### Marker Heatmaps

Visualizing the top markers is useful for the annotation of clusters. The top markers per cluster can be visualized as a heatmap at the single-cell level to ascertain expression variance of the discovered markers.

```{r cluster-expression-heatmap-sc}
## Grab top global markers per cluster; remove mito/RP* family genes
top_markers <- lapply(as.list(markers.bone), function(x) {
    rownames(x)[1:3]
})
top_markers <- sort(unique(unlist(top_markers)))
top_markers <- top_markers[!grepl('MT-|^RP', top_markers)]

## Draw heatmap - single-cell level
set.seed(1234)
dat <- sce.bone[, sample(ncol(sce.bone), 500)]

plotHeatmap(dat,
            features = top_markers,
            symmetric = TRUE, zlim = c(-5, 5), center = TRUE,
            order_columns_by = "cluster",
            show_colnames = FALSE)
```

To reduce plotting time and ease interpretation, the top markers per cluster can also be visualized at the cluster level by aggregating ("pseudobulking") by cluster.

```{r cluster-expression-heatmap-agg}
## Aggregate data to cluster level; average norm. gene expression
sce.agg <- aggregateAcrossCells(sce.bone,
                                ids = sce.bone$cluster,
                                subset_row = top_markers,
                                use_exprs_values = 'logcounts',
                                average = TRUE)


## Draw heatmap - aggregated by cluster level
plotHeatmap(sce.agg,
            features = top_markers,
            symmetric = TRUE, zlim = c(-2, 2), center = TRUE,
            scale = 'row',
            color = scico::scico(n = 101, palette = 'cork'),
            colour_columns_by = 'cluster',
            clustering_method = 'ward.D2',
            cluster_distance_cols = 'correlation',
            cluster_distance_rows = 'correlation',            
            show_colnames = TRUE)
```


## Gene set Enrichment Analysis

To interpret differential expression (DE) results, gene set enrichment analysis (GSEA) can be performed to annotate DE results. The first step is to acquire a mapping of ENTREZID to gene symbol.

```{r annotation-mapping}
## Get mappings of ENTREZID to Symbol
library(org.Hs.eg.db)
keys_entrez <- keys(org.Hs.eg.db, 'ENTREZID')
mapping_es <- AnnotationDbi::select(org.Hs.eg.db,
                                    keys = keys_entrez,
                                    columns = c('ENTREZID', 'SYMBOL'),
                                    keytype = 'ENTREZID')
mapping_es$ENTREZID <- as.integer(mapping_es$ENTREZID)
```

The next is to parse the gene sets (here we use a "tidy" representation of MSigDB gene sets) and remap them.

```{r annotation-pathways}
## Get pathways of interest - convert to list with symbol
## devtools::install_github('stephenturner/msigdf') # "tidy" MSigDB genesets
library(msigdf)
library(dplyr)
mdb <- dplyr::inner_join(msigdf.human, mapping_es,
                         by = c('entrez' = 'ENTREZID')) %>%
    dplyr::filter(collection == 'c7') %>%
    dplyr::select(-collection, -entrez) %>%
    dplyr::group_nest(geneset)
pathways <- purrr::map(mdb$data, function(x) {
    as.character(x$SYMBOL)
})
names(pathways) <- mdb$geneset
```

Finally, the DE results from the `findMarkers()` function are used to test for differential gene set enrichment using the `fgsea` package.

```{r annotation-fgsea}
## Get stats based on markers search
stats <- markers.bone[[1]]$logFC.2
names(stats) <- rownames(markers.bone[[1]])

## Run fast gene set enrichment analysis
## Returns a data.table object
library(fgsea)
gse <- fgsea(pathways = pathways, 
             stats = stats,
             minSize = 15,
             maxSize = 500,
             nperm = 5000)
```

The enrichment scores of the top up and down pathways can then be plotted as a table:

```{r annotation-viz-fgsea-table}
## Get top pathways based on p-value
topPathwaysUp <- gse[gse$NES > 0][order(gse$pval)[1:2], ]$pathway
topPathwaysDown <- gse[gse$NES < 0][order(gse$pval)[1:2], ]$pathway
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))

plotGseaTable(pathways[topPathways], stats,
              gse, 
              gseaParam = 0.5)
```

Or select pathways can also be plotted as a more traditional running score plot:

```{r annotation-viz-fgsea-es}
## Traditional GSEA plot
plotEnrichment(pathways[[topPathways[1]]],
               stats)
```

### Trajectory analysis

Slingshot relies on providing a set of clusters on which to construct a trajectory.

```{r trajectory, eval=FALSE}
## Trajectory Analysis -------------------------------------
library(slingshot)
slc <- slingshot(sce.bone[, sce.bone$cluster %in% c(1, 2, 3)],
                 clusterLabels = 'cluster',
                 reducedDim = 'UMAP')
```

```{r}
## Interactive Exploration ---------------------------------
## library(iSEE)
## iSEE(sce) ## not run; opens a web browser GUI
```

The calculated principal curve can then be visualized on the UMAP space.

```{r viz-trajectory, eval=FALSE}
## Trajectory analysis -------------------------------------
## Slingshot trajectory plot
library(RColorBrewer)
colors <- colorRampPalette(brewer.pal(11, 'Spectral')[-6])(100)
plotcol <- colors[cut(slc$slingPseudotime_1, breaks = 100)]
plot(reducedDims(slc)$UMAP, col = plotcol, pch=16, asp = 1)
lines(SlingshotDataSet(slc), lwd = 2, col = 'black')
```


## Session Info {-}

```{r sessionInfo, echo=FALSE, results='asis'}
prettySessionInfo()
```
