# Grun mouse HSC (CEL-seq) {#merged-hcsc}

```{r setup, echo=FALSE, results="asis"}
library(OSCAUtils)
chapterPreamble(use_cache = TRUE)
```

## Introduction

This performs an analysis of the mouse haematopoietic stem cell (HSC) dataset generated with CEL-seq [@grun2016denovo].

## Data loading

```{r data-loading}
library(scRNAseq)
sce.grun.hsc <- GrunHSCData(ensembl=TRUE)
```

```{r gene-annotation}
library(AnnotationHub)
ens.mm.v97 <- AnnotationHub()[["AH73905"]]
anno <- select(ens.mm.v97, keys=rownames(sce.grun.hsc), 
    keytype="GENEID", columns=c("SYMBOL", "SEQNAME"))
rowData(sce.grun.hsc) <- anno[match(rownames(sce.grun.hsc), anno$GENEID),]
```

After loading and annotation, we inspect the resulting `SingleCellExperiment` object:

```{r}
sce.grun.hsc
```

## Quality control

```{r}
unfiltered <- sce.grun.hsc
```

For some reason, no mitochondrial transcripts are available, and we have no spike-in transcripts, so we only use the number of detected genes and the library size for quality control.
We block on the sample of origin, detecting low-quality _batches_ based on whether their thresholds are low outliers.
We then recompute the thresholds for those batches using information from the rest of the dataset.
(The situation is rather complex as we have both microdissected cells and sorted HSCs in the same object.
Thus, the "outliers of outlier thresholds" is detected within each protocol.)

```{r quality-control}
library(scater)
stats <- perCellQCMetrics(sce.grun.hsc)
is.micro <- sce.grun.hsc$protocol=="micro-dissected cells"

# Extracting the outlier thresholds for the micro-dissected cells,
# and identifying outliers of the thresholds (using a lower MAD
# count to be more stringent for this set of cells).
stats.micro <- stats[is.micro,]
sample.micro <- sce.grun.hsc$sample[is.micro]

qc.micro <- quickPerCellQC(stats.micro, batch=sample.micro)
lib.size.micro <- attr(qc.micro$low_lib_size, "thresholds")["lower",]
n.genes.micro <- attr(qc.micro$low_n_features, "thresholds")["lower",]

bad.micro <- isOutlier(lib.size.micro, log=TRUE, type="lower", nmads=2) |
    isOutlier(n.genes.micro, log=TRUE, type="lower", nmads=2)
qc.micro <- quickPerCellQC(stats.micro, batch=sample.micro,
    subset=!sample.micro %in% names(which(bad.micro)))

# Repeating for the sorted HSCs:
stats.hsc <- stats[!is.micro,]
sample.hsc <- sce.grun.hsc$sample[!is.micro]

qc.hsc <- quickPerCellQC(stats.hsc, batch=sample.hsc)
lib.size.hsc <- attr(qc.hsc$low_lib_size, "thresholds")["lower",]
n.genes.hsc <- attr(qc.hsc$low_n_features, "thresholds")["lower",]

bad.hsc <- isOutlier(lib.size.hsc, log=TRUE, type="lower") |
    isOutlier(n.genes.hsc, log=TRUE, type="lower")
qc.hsc <- quickPerCellQC(stats.hsc, batch=sample.hsc,
    subset=!sample.hsc %in% names(which(bad.hsc)))

# Actually performing the QC.
overall.discard <- logical(ncol(sce.grun.hsc))
overall.discard[is.micro] <- qc.micro$discard
overall.discard[!is.micro] <- qc.hsc$discard
sce.grun.hsc <- sce.grun.hsc[,!overall.discard]
```

We examine the number of cells discarded for each reason.

```{r}
colSums(as.matrix(qc.micro))
colSums(as.matrix(qc.hsc))
```

We create some diagnostic plots for each metric (Figure \@ref(fig:unref-hgrun-qc-dist)).
It must be said that the library sizes are unusually low for many plates of micro-dissected cells; this may be attributable to damage induced by the extraction protocol compared to cell sorting.

```{r unref-hgrun-qc-dist, fig.asp=1, fig.wide=TRUE, fig.cap="Distribution of each QC metric across cells in the Grun HSC dataset. Each point represents a cell and is colored according to whether that cell was discarded."}
colData(unfiltered) <- cbind(colData(unfiltered), stats)
unfiltered$discard <- overall.discard

gridExtra::grid.arrange(
    plotColData(unfiltered, y="sum", x="sample", colour_by="discard", 
        other_fields="protocol") + scale_y_log10() + ggtitle("Total count") +
        facet_wrap(~protocol),
    plotColData(unfiltered, y="detected", x="sample", colour_by="discard",
        other_fields="protocol") + scale_y_log10() + 
        ggtitle("Detected features") + facet_wrap(~protocol),
    ncol=1
)
```

We see that the batches containing the discarded cells are also those identified as the "bad" batches:

```{r}
names(which(bad.micro))
names(which(bad.hsc))
```

```{r, echo=FALSE}
stopifnot("JC28" %in% names(which(bad.micro)))
stopifnot(identical(names(which(bad.hsc)), "JC4"))
```

## Normalization

```{r normalization}
library(scran)
set.seed(101000110)
clusters <- quickCluster(sce.grun.hsc)
sce.grun.hsc <- computeSumFactors(sce.grun.hsc, clusters=clusters)
sce.grun.hsc <- logNormCounts(sce.grun.hsc)
```

We examine some key metrics for the distribution of size factors, and compare it to the library sizes as a sanity check (Figure \@ref(fig:unref-hgrun-norm)).

```{r}
summary(sizeFactors(sce.grun.hsc))
```

```{r unref-hgrun-norm, fig.cap="Relationship between the library size factors and the deconvolution size factors in the Grun HSC dataset."}
plot(librarySizeFactors(sce.grun.hsc), sizeFactors(sce.grun.hsc), pch=16,
    xlab="Library size factors", ylab="Deconvolution factors", log="xy")
```

## Variance modelling

We create a mean-variance trend based on the expectation that UMI counts have Poisson technical noise.
We do not block on sample here as we want to preserve any difference between the micro-dissected cells and the sorted HSCs.

```{r variance-modelling}
set.seed(00010101)
dec.grun.hsc <- modelGeneVarByPoisson(sce.grun.hsc) 
top.grun.hsc <- getTopHVGs(dec.grun.hsc, prop=0.1)
```

The lack of a typical "bump" shape in Figure \@ref(fig:unref-hgrun-var) is caused by the low counts.

```{r unref-hgrun-var, fig.cap="Per-gene variance as a function of the mean for the log-expression values in the Grun HSC dataset. Each point represents a gene (black) with the mean-variance trend (blue) fitted to the simulated Poisson-distributed noise."}
plot(dec.grun.hsc$mean, dec.grun.hsc$total, pch=16, cex=0.5,
    xlab="Mean of log-expression", ylab="Variance of log-expression")
curfit <- metadata(dec.grun.hsc)
curve(curfit$trend(x), col='dodgerblue', add=TRUE, lwd=2)
```

## Dimensionality reduction

```{r dimensionality-reduction}
set.seed(101010011)
sce.grun.hsc <- denoisePCA(sce.grun.hsc, technical=dec.grun.hsc, subset.row=top.grun.hsc)
sce.grun.hsc <- runTSNE(sce.grun.hsc, dimred="PCA")
```

We check that the number of retained PCs is sensible.

```{r}
ncol(reducedDim(sce.grun.hsc, "PCA"))
```

## Clustering

```{r clustering}
snn.gr <- buildSNNGraph(sce.grun.hsc, use.dimred="PCA")
sce.grun.hsc$cluster <- factor(igraph::cluster_walktrap(snn.gr)$membership)
```

```{r}
table(sce.grun.hsc$cluster)
```

```{r unref-hgrun-tsne, fig.wide=TRUE, fig.cap="Obligatory $t$-SNE plot of the Grun HSC dataset, where each point represents a cell and is colored according to the assigned cluster (left) or extraction protocol (right)."}
short <- ifelse(grepl("micro", sce.grun.hsc$protocol), "micro", "sorted")
gridExtra:::grid.arrange(
    plotTSNE(sce.grun.hsc, colour_by="cluster"),
    plotTSNE(sce.grun.hsc, colour_by=I(short)),
    ncol=2
)
```

## Marker gene detection

```{r marker-detection}
markers <- findMarkers(sce.grun.hsc, sce.grun.hsc$cluster, 
    test.type="wilcox", direction="up",
    row.data=rowData(sce.grun.hsc)[,"SYMBOL",drop=FALSE])
```

```{r, echo=FALSE}
cluster <- "2"
```

To illustrate the manual annotation process, we examine the marker genes for one of the clusters.
Upregulation of _Camp_, _Cd177_, _S100a9_ and lysozyme genes indicates that this cluster contains cells of neuronal origin.

```{r unref-heat-hgrun-markers, fig.asp=1.5, fig.cap=sprintf("Heatmap of the AUCs for the top marker genes in cluster %s compared to all other clusters in the Grun HSC dataset.", cluster)}
chosen <- markers[['2']]
best <- chosen[chosen$Top <= 10,]
aucs <- getMarkerEffects(best, prefix="AUC")
rownames(aucs) <- best$SYMBOL

library(pheatmap)
pheatmap(aucs, color=viridis::plasma(100))
```

```{r, echo=FALSE}
# Checking my statements:
stopifnot(identical(chosen, markers[[cluster]]))
stopifnot(all(c("Camp", "Cd177", "S100a9", "Lyz1") %in% rownames(aucs)))
```

## Session Info {-}

```{r sessionInfo, echo=FALSE, results='asis'}
prettySessionInfo()
```
