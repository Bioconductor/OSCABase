---
output:
  html_document
bibliography: ../ref.bib
---

# Analyzing repertoire sequencing data {#repertoire-seq}

```{r setup, echo=FALSE, results="asis"}
library(OSCAUtils)
chapterPreamble()
```

```{r, fig.cap="This page is under construction.", echo=FALSE}
path <- fetchOSCAImage("placeholder_yuno.jpg")
knitr::include_graphics(path)
```

## Motivation

An organism's immune repertoire is defined as the set of T and B cell subtypes that contain genetic diversity in the T cell receptor (TCR) components or immunoglobin chains, respectively.
This diversity is important for ensuring that the adaptive immune system can respond effectively to a wide range of antigens.
We can profile the immune repertoire by simply sequencing the relevant transcripts [@georgiou2014promise;@rosati2017overview], a procedure that can be combined with previously mentioned technologies [@zheng2017massively] to achieve single-cell resolution.
This data can then be used to characterize an individual's immune response based on the expansion of T or B cell clones, i.e., multiple cells with the same sequences for each TCR component or immunoglobulin chain.

By itself, repertoire sequencing data can be readily analyzed using tools from the [ImmCantation suite](https://immcantation.readthedocs.io/en/stable/).
In particular, the `r CRANpkg("alakazam")` package provides functions to perform common analyses to quantify clonal diversity, reconstruct lineages, examine amino acid properties, etc.
However, in most experiments, we also obtain standard RNA sequencing data for each cell; the challenge lies in how we can integrate these two datasets together in the same analysis.
This is not entirely trivial as each cell may have zero, one or multiple sequences for any given repertoire component, whereas we only obtain a single expression profile for that cell.

We would like to define a single data structure that captures both the expression profile and repertoire state for each cell.
This ensures synchronization during operations like subsetting (as previously discussed for the `SingleCellExperiment` class) and reduces book-keeping errors throughout the course of an interactive analysis.
We achieve this using the `SplitDataFrameList` class from the `r Biocpkg("IRanges")` package, which allows us to accommodate repertoire sequencing data into existing Bioconductor classes while retaining compatibility with ImmCantation functions.
We demonstrate on a publicly available 10X Genomics dataset using mouse PBMCs, for which the expression and ADT data have already been processed below:

```{r, echo=FALSE, results="asis"}
extractCached("tenx-repertoire-pbmc8k", "clustering", "sce.pbmc")
```

```{r}
sce.pbmc

# Moving ADT-based clustering to the top level for convenience.
sce.pbmc$cluster <- altExp(sce.pbmc)$cluster
```

## Analyzing the T cell receptor repertoire

### Data processing

First, we obtain the filtered TCR contig annotations for the same set of cells.
Each row of the resulting data frame contains information about a single TCR component sequence in one cell, broken down into the alleles of the V(D)J genes making up that component (`v_gene`, `d_gene`, `j_gene`) where possible. 
The number of reads and UMIs supporting the set of allele assignments for a cell is also shown, though only the UMI count should be used for quantifying expression of a particular TCR sequence.
Each cell is assigned to a clonotype (`raw_clonotype_id`) based on the combination of the $\alpha$-chain (TRA) and $\beta$-chain (TRB) sequences in that cell.

```{r}
library(BiocFileCache)
bfc <- BiocFileCache(ask=FALSE)
tcr.data <- bfcrpath(bfc, file.path(
    "http://cf.10xgenomics.com/samples/cell-vdj/3.1.0",
    "vdj_v1_hs_pbmc3/vdj_v1_hs_pbmc3_t_filtered_contig_annotations.csv"))
tcr <- read.csv(tcr.data, stringsAsFactors=FALSE)
nrow(tcr)
head(tcr)
```

The challenge in incorporating all of these data structures into a single object lies in the fact that each cell may have zero, one or many TCR/immunoglobulin sequences.
This precludes direct storage of repertoire information in the `colData()` of the `SingleCellExperiment`, which expects a 1:1 mapping from each cell to each repertoire sequence.
Instead, we store the repertoire data as a `SplitDataFrameList` object where each cell is represented by a `DataFrame` and each row of that `DataFrame` represents a sequence for that cell.
This is easily done using the `splitToCells()` utility function from the `r Githubpkg("LTLA/RepertoireUtils")` package, as shown below. 
(We set the `universe=` argument to ensure that the `SplitDataFrameList` has the same number and order of cells in our `sce.pbmc` object, even if some cells have no sequences, i.e., zero-row `DataFrame`s.)

```{r}
library(RepertoireUtils)

# For the alpha chain sequences:
sce.pbmc$TRA <- splitToCells(tcr[tcr$chain=="TRA",], 
    field="barcode", universe=sce.pbmc$Barcode)

# Inspecting the class:
class(sce.pbmc$TRA)
length(sce.pbmc$TRA) # Now the same as the number of cells.

# Repeating for the beta chain:
sce.pbmc$TRB <- splitToCells(tcr[tcr$chain=="TRB",], 
    field="barcode", universe=sce.pbmc$Barcode)
```

### Basic diagnostics

We start by generating some basic diagnostics using the `countSequencesPerCell()` function.
This returns the number of sequences for each cell, possibly after some simple filtering on the sequence characteristics.
Here, we assemble a matrix indicating whether each cell has any TCR $\alpha$-chain sequence,
multiple sequences or productive, full-length or high-confidence sequences.
We also determine whether each cell has an "awesome" sequence that is productive, full-length and high-confidence.
We use this information to compute the proportion of cells in each cluster that are positive for each metric.

```{r}
status <- rbind(
    HasAnySequence=countSequencesPerCell(sce.pbmc$TRA) > 0,
    HasMultiSequence=countSequencesPerCell(sce.pbmc$TRA) > 1,
    HasProductiveSequence=countSequencesPerCell(sce.pbmc$TRA,
        filter.field="productive", filter.value="True") > 0,
    HasFullLengthSequence=countSequencesPerCell(sce.pbmc$TRA,
        filter.field="full_length", filter.value="True") > 0,
    HasHighConfSequence=countSequencesPerCell(sce.pbmc$TRA,
        filter.field="high_confidence", filter.value="True") > 0,
    HasAwesomeSequence=countSequencesPerCell(sce.pbmc$TRA,
        filter.field=c("productive", "full_length", "high_confidence"),
        filter.value=c("True", "True", "True")) > 0
)

stats <- colsum(status+0, sce.pbmc$cluster)
props <- t(t(stats)/as.numeric(table(sce.pbmc$cluster)))
props[,1:10]
```

We then identify clusters of T cells as those with large proportions of TCR-expressing cells (Figure \@ref(fig:tcra-prop-cluster)).
Some background level of TCR expression may be observed in other clusters due to a mixture of clustering uncertainty, ambient contamination, doublet formation and - in more unusual cases - genuine expression in other cell types.
We would also generally expect a high proportion of awesome sequences, as a large proportion of low-confidence or non-full-length sequences indicates that the sequencing was not deep enough for successful alignment and assembly.

```{r tcra-prop-cluster, fig.width=10, fig.wide=TRUE, fig.cap="Proportion of cells in each cluster that express TCR $\\alpha$-chain sequences in the PBMC dataset."}
library(reshape2)
library(ggplot2)
tmp <- melt(props)
colnames(tmp) <- c("Type", "Cluster", "Proportion")
tmp$Cluster <- factor(tmp$Cluster)
ggplot(tmp, aes(x=Cluster, y=Proportion, fill=factor(Type))) +
    geom_bar(stat="identity", position="dodge", colour="black") +
    scale_fill_brewer(type="qual", palette=1)
```

The proportion of cells with multiple sequences is an interesting metric.
In most cells contributing to the immune repertoire, allelic exclusion ensures that only one TCR $\alpha$-chain (or $\beta$-chain, or immunoglobulin heavy/light-chain for B cells) is actively expressed [@brady2010antigen].
We might then expect that the substantial proportion of multi-sequence-expressing cells in Figure \@ref(fig:tcra-prop-cluster) is a symptom of some technical problem like doublets or ambient contamination.
However, it is also known a substantial proportion of T cells are able to escape allelic exclusion and express multiple sequences, so the magnitude of these proportions are not necessarily problematic.

We can explore this phenomenon in more detail with the `topCoveragePropPerCell()` function, which returns the proportion of UMI counts allocated to the most abundant $\alpha$-chain sequence within each cell.
Figure \@ref(fig:tcra-top-umi-prop) suggests that, if a cell has multiple sequences, the secondary sequence is expressed at a level comparable to the primary sequence.
This indicates that the presence of multiple sequences cannot be wholly attributed to a low level of background contamination, otherwise we would expect most ratios to be close to 0.

```{r tcra-top-umi-prop, fig.cap="Distribution of the ratio of UMIs assigned to the second-most abundant sequence in each cell compared to the most abundant sequence, across all cells with multiple sequences in the PBMC dataset."}
second.ratio <- topCoveragePropPerCell(sce.pbmc$TRA, 
    cov.field="umis", second.ratio=TRUE)
hist(second.ratio[second.ratio!=0], col="grey", 
    xlab="Ratio of UMIs of second sequence to top",
    ylab="Number of cells")
```

Finally, it can be valuable to compute the ratio of reads to UMIs across all cells (Figure \@ref(fig:tcra-read-umi-ratio)).
Unlike gene expression, the ratio tends to be very large in repertoire data as the space of available transcripts is much smaller.
In addition, the processing tends to select for large ratios as sequences are only reported if they are sufficiently well-sequenced for alignment, assembly and gene assignment.
We would generally expect most sequences to have around 1000 reads per transcript molecule, and a lower ratio may indicate that deeper sequencing is required.

```{r tcra-read-umi-ratio, fig.cap="Distribution of read-to-UMI ratios across all cells in the PBMC dataset. Counts are summed over all sequences for a cell if multiple sequences are available."}
read.umi <- readToUmiPerCell(sce.pbmc$TRA, umi.field="umis", read.field="reads")
hist(read.umi, col="grey", 
    xlab="Ratio of reads to UMIs",
    ylab="Number of cells")
```

### Custom diagnostics with `List` grammar

At this point, it is worth spending some time on the sheer power of the `List` grammar from the `r Biocpkg("IRanges")` package.
We can easily assemble complex queries on the table of contig sequence information by using nothing more than basic R syntax.
To illustrate, we will use the $\alpha$-chain data to extract some complex features,
starting with the identification of sequences that have UMI counts no less than 50% of the largest UMI count for the same cell.

```{r}
# Assigning to a short-name variable for convenience.
tra <- sce.pbmc$TRA

# Obtaining the maximum UMI count for each cell.
max.umi <- max(tra[,"umis"])
head(max.umi)

# Generate a LogicalList indicating which sequences have UMI counts
# greater than half the maximum UMI count in the same cell.
keep <- tra[,"umis"] >= max.umi/2
keep

# Count the number of sequences satisfying this requirement per cell.
head(sum(keep))
```

Boolean statements are easily accommodated with standard methods.
For example, we can identify sequences that are full-length, productive and have the largest UMI count in the cell.
Another useful aspect of the `SplitDataFrameList`'s behavior is that we can use a `LogicalList` as a subsetting argument, which will apply the subsetting at the sequence level, i.e., the rows of each per-cell `DataFrame`.
(This contrasts with more conventional uses of a logical subsetting vector that simply subsets at the cell level, i.e., the elements of the `SplitDataFrameList` itself.)

```{r}
keep <- tra[,"full_length"]=="True" &
    tra[,"productive"]=="True" &
    tra[,"umis"] == max(tra[,"umis"])
keep 

# Subsets the SplitDataFrameList to only retain sequences in each cell that
# satisfy our requirements (note, this does not change the total number of
# cells, only the number of sequences per cell).
tra.sub <- tra[keep]
```

The grammar also extends to dealing with character vectors.
Say we want to quantify all combinations of V and J genes, each of which is extracted from `tra` as a `CharacterList` object. 
The simplest approach is to simply `paste()` the `CharacterList` objects together and count the frequencies of the concatenated strings, as shown below.

```{r}
combined <- paste(tra[,"v_gene"], tra[,"j_gene"])
combined

combo.freq <- table(unlist(combined))
head(sort(combo.freq, decreasing=TRUE))
```

If an operation must be performed on the original sequence-level data frame, 
we can efficiently recover the latter by calling `unlist()` on our `SplitDataFrameList`.
It is similarly straightforward to regenerate our `SplitDataFrameList` from the data frame by using the `relist()` command. 
This framework permits users to quickly switch between sequence level and cell level perspectives of the repertoire data depending on which is most convenient at any given point in the analysis.

```{r}
tra.seq <- unlist(tra)
dim(tra.seq) # Each row represents a sequence now.

# Adding some arbitrary extra annotation (mocked up here).
extra.anno <- DataFrame(anno=sample(LETTERS, nrow(tra.seq), replace=TRUE))
tra.seq <- cbind(tra.seq, extra.anno)

# Regenerating the SplitDataFrameList from the modified DataFrame.
tra2 <- relist(tra.seq, tra)
length(tra2) # Each element represents a cell again.
```

### Quantifying gene expression

We use the `countCellsPerGeneCombo()` function to count the number of cells expressing each gene or combination thereof.
The function returns a `SummarizedExperiment` object containing the number of cells expressing each gene combination (row) in each level of the grouping factor (column).
In this case, we stratify the counts by the cluster of origin such that each column corresponds to one of our clusters.
For simplicity, we will also set `cov.field="umis"` so that only the most abundant sequence from each cell is considered during counting.

```{r}
se.genes <- countCellsPerGeneCombo(sce.pbmc$TRA,
    gene.field=c("v_gene", "d_gene", "j_gene", "c_gene"),
    group=sce.pbmc$cluster,
    cov.field="umis"
)
rowData(se.genes)
head(assay(se.genes))
```

```{r, echo=FALSE}
greedy.bastard <- "2"
```

We can summarize the diversity of gene expression within each grouping level using the `summarizeGeneComboCounts()` function.
This computes the Gini index, a measure of the unevenness of the distribution of counts among gene combinations in each cluster;
the proportion of counts assigned to the top $T$ gene combinations;
and the Hill numbers of varying order, 
which quantify the number of unique combinations (`"hill0"`) or the evenness of their abundances (`"hill1"`, `"hill2"`).
We can see that cluster `r greedy.bastard` has the most uneven count distribution by some margin, indicating that the $\alpha$-chain expression in this cluster is dominated by only a small number of gene combinations;
this is possibly interesting if it reflects an immune response to particular epitopes.

```{r}
set.seed(100)
has.tcr <- colSums(assay(se.genes)) >= 100
sum.genes <- summarizeGeneComboCounts(se.genes[,has.tcr])
sum.genes
```

```{r, echo=FALSE}
stopifnot(
    which.max(sum.genes[,"gini"])==which(rownames(sum.genes)==greedy.bastard)
)
```

Note that the `summarizeGeneComboCounts()` function will first downsample all groups to have the same total number of cells.
The diversity indices are sensitive to the sample size, especially at small values, meaning that it is difficult to compare indices computed from different total numbers of cells.
Here, we only consider clusters with at least 100 cells to ensure that we have enough cells after downsampling.
(Otherwise, we would not obtain meaningful comparisons after downsampling to, say, 10 cells per cluster.)
We also need to set the seed to obtain reproducible results when downsampling..

The obvious next step is to identify significant differences in the expression frequency of each gene combination between clusters.
Here, the `testGeneComboCountsBetweenGroups()` function performs a one-sided Fisher's exact test on each gene combination to detect differences in the proportion of expressing cells between pairs of clusters.
We then arrange the results into a single list of combinations per cluster, equivalent to the marker detection methods described in Chapter \@ref(marker-detection).
We see that cluster `r greedy.bastard` has a number of gene combinations that are not expressed in any other cluster; upregulation of TRAV1-2--TRAJ33 suggests that this cluster contains mucosal-associated invariant T cells [@reantragoon2013antigen].

```{r}
# Only using TCR-containing clusters for simplicity:
test.out <- testGeneComboCountsBetweenGroups(se.genes[,has.tcr])
test.out[["2"]]
```

```{r, echo=FALSE}
# Checking my smack:
stopifnot(grepl("TRAV1-2", rownames(test.out)[1:5]))
stopifnot(grepl("TRAJ33", rownames(test.out)[1:5]))
```

### Quantifying clonal expansion

Quantification of clonal expansion is the most obvious application of repertoire sequencing data.
Cells with the same T cell clonotype are assumed to target the same antigen, and any increase in the frequency of a clonotype provides evidence for T cell activation and proliferation upon stimulation by the corresponding antigen.
Thus, we can gain some insights into the immune activity of each T cell cluster by counting the number of expanded clonotypes in each cluster, as shown below for the $\alpha$-chain.
(We do not exclude clonotypes containing cells in different clusters, which can arise for various genuine biological reasons, e.g., differences in the microenvironment.) 

```{r, fig.cap="Proportion of cells in each cluster that have multiple clonotypes, based on the TCR $\\alpha$ or $\\beta$-chains."}
# TODO: shovel this inside a package somewhere:
clone.id.A <- unlist(unique(sce.pbmc$TRA[,"raw_clonotype_id"]))
expanded.id.A <- setdiff(clone.id.A[duplicated(clone.id.A)], "None")
length(expanded.id.A) # number of expanded clonotypes for TRA

clone.id.B <- unlist(unique(sce.pbmc$TRB[,"raw_clonotype_id"]))
expanded.id.B <- setdiff(clone.id.B[duplicated(clone.id.B)], "None")
length(expanded.id.B) # number of expanded clonotypes for TRB

is.clone.A <- any(sce.pbmc$TRA[,"raw_clonotype_id"] %in% expanded.id.A)
tra.counts.clonal <- table(sce.pbmc$cluster[is.clone.A])
is.clone.B <- any(sce.pbmc$TRB[,"raw_clonotype_id"] %in% expanded.id.B)
trb.counts.clonal <- table(sce.pbmc$cluster[is.clone.B])

barplot(rbind(TRA=tra.counts.clonal/ncells, TRB=trb.counts.clonal/ncells), 
    legend=TRUE, beside=TRUE)
```

We can use this information to determine whether a particular T cell cluster is enriched for expanding clonotypes.
The example below uses Fisher's exact test to identify a significant increase in the proportion of expanded clonotypes in a cluster of putative CD8^+^ T cells compared to another cluster of CD4^+^ T cells (Figure \@ref(fig:expanded-t-clusters)).
This provides some relative measure of the average immune activity of each cluster though, of course, further subclustering may reveal finer subpopulations with more or less activity than the average of the parent cluster.

```{r expanded-t-clusters, fig.wide=TRUE, fig.asp=1, fig.cap="Distribution of log-abundance values for each antibody-derived tag in the PBMC dataset, across all cells in either T cell cluster (top and bottom panels)."}
# Identifying the clusters:
tclust.1 <- "2"
tclust.2 <- "6"

mat <- cbind(Expanded=tra.counts.clonal,
    Unexpanded=tra.counts.any - tra.counts.clonal)[c(tclust.1, tclust.2),]
mat 

stats <- fisher.test(mat)
stats

# Checking the identities of the relevant clusters. Note that 'cluster' is also
# present as a colData entry in 'altExp(sce.pbmc)', which is why the
# 'other_fields="cluster"' argument works correctty.
of.interest <- sce.pbmc$cluster %in% c(tclust.1, tclust.2)

library(scater)
plotExpression(altExp(sce.pbmc)[,of.interest], 
    features=rownames(altExp(sce.pbmc)),
    other_fields="cluster") + facet_wrap(~cluster, ncol=1)
```

```{r, echo=FALSE}
# Checking identities of all relevant entities.
stopifnot(all(mat[,2] > 100))
stopifnot(any(mat[,1] > 100))
stopifnot(stats$p.value <= 0.01)

ave.markers <- sumCountsAcrossCells(altExp(sce.pbmc), sce.pbmc$cluster,
    exprs_values="logcounts", average=TRUE)
stopifnot(diff(ave.markers["CD8a", c(tclust.1, tclust.2)]) < -4)
stopifnot(diff(ave.markers["CD4", c(tclust.1, tclust.2)]) > 5)
```

## Analyzing the immunoglobulin repertoire

Immunoglobulins are good.

## Multi-sample analyses

A much more interesting analysis is possible when there are multiple samples and treatment conditions, where the aim is to determine which clusters contain T cell clonotypes that expand in response to treatment.
In much the same vein as the analysis in Chapter \@ref(multi-sample-comparisons), we can obtain a cluster-by-sample count matrix by simply `cbind()`ing together the `tra.counts.clonal` vector from each sample.
To demonstrate, we will pretend that our cells are derived from 4 samples that have been merged together for common clustering (Chapter \@ref(integrating-datasets)).

```{r}
pretend.samples <- sample(letters[1:4], ncol(sce.pbmc), replace=TRUE)

# Creating a count matrix.
clone.counts <- any.counts <- list()
for (i in sort(unique(pretend.samples))) {
    current.sample <- sce.pbmc[,i==pretend.samples]
    clone.id.A <- unlist(unique(current.sample$TRA[,"raw_clonotype_id"]))
    expanded.id.A <- setdiff(clone.id.A[duplicated(clone.id.A)], "None")
    is.clone.A <- any(current.sample$TRA[,"raw_clonotype_id"] %in% expanded.id.A)
    clone.counts[[i]] <- table(current.sample$cluster[is.clone.A])
    any.counts[[i]] <- table(current.sample$cluster[lengths(current.sample$TRA) > 0])
}

clone.counts <- do.call(cbind, clone.counts)
any.counts <- do.call(cbind, any.counts)
```

We then test for condition-specific differences in the proportion of clonotypes that are expanded.
A natural approach would be to apply a beta-binomial model to each cluster, using the expanded and TCR-containing counts as input; for the time being, though, we will just perform a simple Wilcoxon ranked sum test.
We test on proportions to accommodate biological differences in T cell abundance between samples well as technical differences in, say, sequencing depth that might affect the success rate of TCR calls on a sample-by-sample basis.

```{r}
prop <- clone.counts/any.counts

# Pretending that the first two samples are cases,
# and the second two samples are controls.
wilcox.test(prop[tclust.1,1:2], prop[tclust.1,3:4])
wilcox.test(prop[tclust.2,1:2], prop[tclust.2,3:4])
```

## Session Info {-}

```{r sessionInfo, echo=FALSE, results='asis'}
prettySessionInfo()
```
