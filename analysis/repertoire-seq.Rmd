---
output:
  html_document
bibliography: ../ref.bib
---

# Analyzing repertoire sequencing data {#repertoire-seq}

```{r setup, echo=FALSE, results="asis"}
library(OSCAUtils)
chapterPreamble()
```

```{r, fig.cap="This page is under construction.", echo=FALSE}
path <- fetchImage("placeholder_yuno.jpg")
knitr::include_graphics(path)
```

## Motivation

An organism's immune repertoire is defined as the set of T and B cell subtypes that contain genetic diversity in the T cell receptor (TCR) components or immunoglobin chains, respectively.
This diversity is important for ensuring that the adaptive immune system can respond effectively to a wide range of antigens.
We can profile the immune repertoire by simply sequencing the relevant transcripts [@georgiou2014promise;@rosati2017overview], a procedure that can be combined with previously mentioned technologies [@zheng2017massively] to achieve single-cell resolution.
This data can then be used to characterize an individual's immune response based on the expansion of T or B cell clones, i.e., multiple cells with the same sequences for each TCR component or immunoglobulin chain.

By itself, repertoire sequencing data can be readily analyzed using tools from the [ImmCantation suite](https://immcantation.readthedocs.io/en/stable/).
In particular, the `r CRANpkg("alakazam")` package provides functions to perform common analyses to quantify clonal diversity, reconstruct lineages, examine amino acid properties, etc.
However, in most experiments, we also obtain standard RNA sequencing data for each cell; the challenge lies in how we can integrate these two datasets together in the same analysis.
This is not entirely trivial as each cell may have zero, one or multiple sequences for any given repertoire component, whereas we only obtain a single expression profile for that cell.

We would like to define a single data structure that captures both the expression profile and repertoire state for each cell.
This ensures synchronization during operations like subsetting (as previously discussed for the `SingleCellExperiment` class) and reduces book-keeping errors throughout the course of an interactive analysis.
We achieve this using the `SplitDataFrameList` class from the `r Biocpkg("IRanges")` package, which allows us to accommodate repertoire sequencing data into existing Bioconductor classes while retaining compatibility with ImmCantation functions.
We demonstrate on a publicly available 10X Genomics dataset using mouse PBMCs, for which the expression and ADT data have already been processed below:

```{r, echo=FALSE, results="asis"}
extractCached("tenx-repertoire-pbmc8k", "clustering", "sce.pbmc")
```

```{r}
sce.pbmc

# Moving ADT-based clustering to the top level for convenience.
sce.pbmc$cluster <- altExp(sce.pbmc)$cluster
```

## Analyzing the T cell receptor repertoire

### Data processing

First, we obtain the filtered TCR contig annotations for the same set of cells.
Each row of the resulting data frame contains information about a single TCR component sequence in one cell, broken down into the alleles of the V(D)J genes making up that sequence (`v_gene`, `d_gene`, `j_gene`).
The number of reads and UMIs supporting the set of allele assignments for a cell is also shown, though only the UMI count should be used for quantifying expression of a particular sequence.
Each cell is assigned to a clonotype (`raw_clonotype_id`) based on the combination of the $\alpha$-chain (TRA) and $\beta$-chain (TRB) sequences in that cell.

```{r}
library(BiocFileCache)
bfc <- BiocFileCache(ask=FALSE)
tcr.data <- bfcrpath(bfc, file.path(
    "http://cf.10xgenomics.com/samples/cell-vdj/3.1.0",
    "vdj_v1_hs_pbmc3/vdj_v1_hs_pbmc3_t_filtered_contig_annotations.csv"))
tcr <- read.csv(tcr.data, stringsAsFactors=FALSE)
nrow(tcr)
head(tcr)
```

The challenge with this data lies in the fact that each cell may have zero, one or many $\alpha$ chain sequences.
This precludes direct storage of repertoire information in the `colData()` of the `SingleCellExperiment`, which expects a 1:1 mapping from each cell to its sequence information.
Instead, we store the repertoire data as a `SplitDataFrameList` object where each cell is represented by a `DataFrame` and each row of that `DataFrame` represents a sequence for that cell.
This is easily done using the `splitDataFrameByCell()` utility function from the `r Githubpkg("LTLA/RepertoireUtils")` package, as shown below. 
(We set the `universe=` argument to ensure that the `SplitDataFrameList` has the same number and order of cells in our `sce.pbmc` object, even if some cells have no sequences, i.e., zero-row `DataFrame`s.)

```{r}
library(RepertoireUtils)

# For the alpha chain sequences:
sce.pbmc$TRA <- splitDataFrameByCell(tcr[tcr$chain=="TRA",], 
    field="barcode", universe=sce.pbmc$Barcode)

# Inspecting the class:
class(sce.pbmc$TRA)
length(sce.pbmc$TRA) # Now the same as the number of cells.

# Repeating for the beta chain:
sce.pbmc$TRB <- splitDataFrameByCell(tcr[tcr$chain=="TRB",], 
    field="barcode", universe=sce.pbmc$Barcode)
```

### Basic diagnostics

We start by generating some basic diagnostics using the `summarizeSequenceStatus()` function.
Using the TCR $\alpha$-chain as an example, we assemble a `DataFrame` indicating whether each cell has any sequence,
multiple sequences or productive, full-length or high-confidence sequences.
We also determine whether each cell has an "awesome" sequence that is productive, full-length and high-confidence.
We use this information to compute the proportion of cells in each cluster that are positive for each metric.

```{r}
props <- summarizeSequenceStatus(sce.pbmc$TRA, group=sce.pbmc$cluster)
head(props)
```

We then identify clusters of T cells as those with large proportions of TCR-expressing cells (Figure \@ref(fig:tcra-prop-cluster)).
Some background level of TCR expression may be observed in other clusters due to a mixture of clustering uncertainty, ambient contamination, doublet formation and - in more unusual cases - genuine expression in other cell types.
We would also generally expect a high proportion of awesome sequences, as a large proportion of low-confidence or non-full-length sequences indicates that the sequencing was not deep enough for successful alignment and assembly.

```{r tcra-prop-cluster, fig.width=10, fig.wide=TRUE, fig.cap="Proportion of cells in each cluster that express TCR $\\alpha$-chain sequences in the PBMC dataset."}
library(reshape2)
library(ggplot2)

tmp <- melt(as.matrix(props))
colnames(tmp) <- c("Cluster", "Type", "Proportion")
tmp$Cluster <- factor(tmp$Cluster)

ggplot(tmp, aes(x=Cluster, y=Proportion, fill=factor(Type))) +
    geom_bar(stat="identity", position="dodge", colour="black") +
    scale_fill_brewer(type="qual", palette=1)
```

The proportion of cells with multiple sequences is an interesting metric.
In most cells contributing to the immune repertoire, allelic exclusion ensures that only one TCR $\alpha$-chain (or $\beta$-chain, or immunoglobulin heavy/light-chain for B cells) is actively expressed [@brady2010antigen].
We might then expect that the substantial proportion of multi-sequence-expressing cells in Figure \@ref(fig:tcra-prop-cluster) is a symptom of some technical problem like doublets or ambient contamination.
However, it is also known a substantial proportion of T cells are able to escape allelic exclusion and express multiple sequences, so the magnitude of these proportions are not necessarily problematic.

We can explore this phenomenon in more detail with the `topCoveragePropPerCell()` function, which returns the proportion of UMI counts allocated to the most abundant $\alpha$-chain sequence within each cell.
Figure \@ref(fig:tcra-top-umi-prop) suggests that, if a cell has multiple sequences, the secondary sequence is expressed at a level comparable to the primary sequence.
This indicates that the presence of multiple sequences cannot be wholly attributed to a low level of background contamination, otherwise we would expect most ratios to be close to 0.

```{r tcra-top-umi-prop, fig.cap="Distribution of the ratio of UMIs assigned to the second-most abundant sequence in each cell compared to the most abundant sequence, across all cells with multiple sequences in the PBMC dataset."}
second.ratio <- topCoveragePropPerCell(sce.pbmc$TRA, 
    cov.field="umis", second.ratio=TRUE)
hist(second.ratio[second.ratio!=0], col="grey", 
    xlab="Ratio of UMIs of second sequence to top",
    ylab="Number of cells")
```

Finally, it can be valuable to compute the ratio of reads to UMIs across all cells (Figure \@ref(fig:tcra-read-umi-ratio)).
Unlike gene expression, the ratio tends to be very large in repertoire data as the space of available transcripts is much smaller.
In addition, the processing tends to select for large ratios as sequences are only reported if they are sufficiently well-sequenced for alignment, assembly and gene assignment.
We would generally expect most sequences to have around 1000 reads per transcript molecule, and a lower ratio may indicate that deeper sequencing is required.

```{r tcra-read-umi-ratio, fig.cap="Distribution of read-to-UMI ratios across all cells in the PBMC dataset. Counts are summed over all sequences for a cell if multiple sequences are available."}
read.umi <- readToUmiPerCell(sce.pbmc$TRA, umi.field="umis", read.field="reads")
hist(read.umi, col="grey", 
    xlab="Ratio of reads to UMIs",
    ylab="Number of cells")
```

### Custom diagnostics with `List` grammar

At this point, it is worth spending some time on the sheer power of the `List` grammar from the `r Biocpkg("IRanges")` package.
We can easily assemble complex queries on the table of contig sequence information by using nothing more than basic R syntax.
To illustrate, we will use the $\alpha$-chain data to extract some complex features,
starting with the identification of sequences that have UMI counts no less than 50% of the largest UMI count for the same cell.

```{r}
# Assigning to a short-name variable for convenience.
tra <- sce.pbmc$TRA

# Obtaining the maximum UMI count for each cell.
max.umi <- max(tra[,"umis"])
head(max.umi)

# Generate a LogicalList indicating which sequences have UMI counts
# greater than half the maximum UMI count in the same cell.
keep <- tra[,"umis"] >= max.umi/2
keep

# Count the number of sequences satisfying this requirement per cell.
head(sum(keep))
```

Boolean statements are easily accommodated with standard methods.
For example, we can identify sequences that are full-length, productive and have the largest UMI count in the cell.
Another useful aspect of the `SplitDataFrameList`'s behavior is that we can use a `LogicalList` as a subsetting argument, which will apply the subsetting at the sequence level, i.e., the rows of each per-cell `DataFrame`.
(This contrasts with more conventional uses of a logical subsetting vector that simply subsets at the cell level, i.e., the elements of the `SplitDataFrameList` itself.)

```{r}
keep <- tra[,"full_length"]=="True" &
    tra[,"productive"]=="True" &
    tra[,"umis"] == max(tra[,"umis"])
keep 

# Subsets the SplitDataFrameList to only retain sequences in each cell that
# satisfy our requirements (note, this does not change the total number of
# cells, only the number of sequences per cell).
tra.sub <- tra[keep]
```

The grammar also extends to dealing with character vectors.
Say we want to quantify all combinations of V and J genes, each of which is extracted from `tra` as a `CharacterList` object. 
The simplest approach is to simply `paste()` the `CharacterList` objects together and count the frequencies of the concatenated strings, as shown below.

```{r}
combined <- paste(tra[,"v_gene"], tra[,"j_gene"])
combined

combo.freq <- table(unlist(combined))
head(sort(combo.freq, decreasing=TRUE))
```

If an operation must be performed on the original sequence-level data frame, 
we can efficiently recover the latter by calling `unlist()` on our `SplitDataFrameList`.
It is similarly straightforward to regenerate our `SplitDataFrameList` from the data frame by using the `relist()` command. 
This framework permits users to quickly switch between sequence level and cell level perspectives of the repertoire data depending on which is most convenient at any given point in the analysis.

```{r}
tra.seq <- unlist(tra)
dim(tra.seq) # Each row represents a sequence now.

# Adding some arbitrary extra annotation (mocked up here).
extra.anno <- DataFrame(anno=sample(LETTERS, nrow(tra.seq), replace=TRUE))
tra.seq <- cbind(tra.seq, extra.anno)

# Regenerating the SplitDataFrameList from the modified DataFrame.
tra2 <- relist(tra.seq, tra)
length(tra2) # Each element represents a cell again.
```

### Quantifying gene expression

We use the `countCellsPerGeneCombo()` function to count the number of cells expressing each gene or combination thereof.
The function returns a `SummarizedExperiment` object containing the number of cells expressing each gene combination (row) in each level of the grouping factor (column).
In this case, we stratify the counts by the cluster of origin such that each column corresponds to one of our clusters.
For simplicity, we will also set `cov.field="umis"` so that only the most abundant sequence from each cell is considered during counting.

```{r}
se.tra <- countCellsPerGeneCombo(sce.pbmc$TRA,
    gene.field=c("v_gene", "d_gene", "j_gene", "c_gene"),
    group=sce.pbmc$cluster,
    cov.field="umis"
)
rowData(se.tra)
head(assay(se.tra))
```

```{r, echo=FALSE}
greedy.bastard <- "2"
```

We can summarize the diversity of gene expression within each grouping level using the `summarizeGeneComboCounts()` function.
This computes the Gini index, a measure of the unevenness of the distribution of counts among gene combinations in each cluster;
the proportion of counts assigned to the top $T$ gene combinations;
and the Hill numbers of varying order, 
which quantify the number of unique combinations (`"hill0"`) or the evenness of their abundances (`"hill1"`, `"hill2"`).
We can see that cluster `r greedy.bastard` has the most uneven count distribution by some margin, indicating that the $\alpha$-chain expression in this cluster is dominated by only a small number of gene combinations;
this is possibly interesting if it reflects an immune response to particular epitopes.

```{r}
set.seed(100)
has.tcr <- colSums(assay(se.tra)) >= 100
sum.genes <- summarizeGeneComboCounts(se.tra[,has.tcr])
sum.genes
```

```{r, echo=FALSE}
stopifnot(
    which.max(sum.genes[,"gini"])==which(rownames(sum.genes)==greedy.bastard)
)
```

Note that the `summarizeGeneComboCounts()` function will first downsample all groups to have the same total number of cells.
The diversity indices are sensitive to the sample size, especially at small values, meaning that it is difficult to compare indices computed from different total numbers of cells.
Here, we only consider clusters with at least 100 cells to ensure that we have enough cells after downsampling.
(Otherwise, we would not obtain meaningful comparisons after downsampling to, say, 10 cells per cluster.)
We also need to set the seed to obtain reproducible results when downsampling..

The obvious next step is to identify significant differences in the expression frequency of each gene combination between clusters.
Here, the `testGeneComboCountsPairwise()` function performs a one-sided Fisher's exact test on each gene combination to detect differences in the proportion of expressing cells between pairs of clusters.
We then arrange the results into a single list of combinations per cluster, equivalent to the marker detection methods described in Chapter \@ref(marker-detection).
We see that cluster `r greedy.bastard` has a number of gene combinations that are not expressed in any other cluster; upregulation of TRAV1-2--TRAJ33 suggests that this cluster contains mucosal-associated invariant T cells [@reantragoon2013antigen].

```{r}
# Only using TCR-containing clusters for simplicity:
test.out <- testGeneComboCountsPairwise(se.tra[,has.tcr])
test.out[["2"]]
```

```{r, echo=FALSE}
# Checking my smack:
stopifnot(grepl("TRAV1-2", rownames(test.out)[1:5]))
stopifnot(grepl("TRAJ33", rownames(test.out)[1:5]))
```

### Quantifying clonal expansion

#### For comparisons between clusters

Quantification of clonal expansion is an obvious application of repertoire sequencing data.
Cells with the same clonotype are assumed to target the same antigen, and any increase in the frequency of a clonotype provides evidence for activation and proliferation upon stimulation by the corresponding antigen.
We gain some insights into the immune activity of each cluster by counting the number of expanded clonotypes, as shown below for the $\alpha$-chain.
(In practice, it is often better to perform the clonotype analysis on the calls in the $\beta$ chain's `SplitDataFrameList`, as this is the preferred source of information regarding clonotype identity - see the next Section for more details - but we will persist with `sce.pbmc$TRA` here for consistency.)

```{r}
clono.tra <- countCellsPerClonotype(sce.pbmc$TRA,
    clone.field="raw_clonotype_id",
    group=sce.pbmc$cluster,
    cov.field="umis"
)
clono.tra
```

It is then a simple matter to examine the distribution of clonotype frequencies using rank abundance curves (Figure \@ref(fig:tcra-pbmc-abundance-rank)).
This yields clear evidence of clonal expansion in one cluster, possibly indicating that it contains cells responding to an immune stimulus.

```{r tcra-pbmc-abundance-rank, fig.cap="Abundance rank curves of clonotype frequencies in each cluster of the PBMC dataset."}
tmp <- data.frame(
    rank=sequence(lengths(clono.tra)),
    frequency=unlist(clono.tra),
    cluster=rep(names(clono.tra), lengths(clono.tra)),
    stringsAsFactors=FALSE
)
ggplot(tmp, aes(x=rank, y=frequency, col=cluster)) + 
    geom_line(size=1.5) +
    scale_x_log10()
```

We quantify this observation by computing diversity indices for clonotypes within each cluster.
More clonal expansion should generally result in lower diversity indices as most cells are represented by a few clonotypes.
Again, we need to downsample each cluster to the same total number of cells, 
so we restrict ourselves to the clusters with a large number of TCR-expressing cells.
The analysis below confirms that cluster `r greedy.bastard` contains the greatest number and extent of expanded clonotypes.

```{r}
set.seed(1000)
clono.out <- summarizeClonotypeCounts(clono.tra[has.tcr])
clono.out
```

```{r, echo=FALSE}
stopifnot(rownames(clono.out)[which.max(clono.out$gini)]==greedy.bastard)
```

We could test the statistical significance of the differences in the diversity indices by performing pairwise comparisons between groups with a permutation test in `testClonotypeCountsPairwise()`.
This yields a matrix of $p$-values for each comparison, adjusted for multiple testing across all pairs for a given index.
In practice, this analysis is not particularly helpful as the large number of cells means that the null hypothesis can be consistently rejected even when there are only small differences in the diversity indices.

```{r}
set.seed(1010010)
test.out <- testClonotypeCountsPairwise(clono.tra[has.tcr])
test.out$hill1 # significant differences in Hill index of order 1.
```

#### Shared clonotypes across clusters

The previous analysis does not consider the possibility of clonotypes with cells in different clusters.
This might arise for various genuine biological reasons - for example, if a single T cell clone is captured at varying activation states, we may observe the same clonotype in naive, effector and memory populations.
To quantify sharing, we use the `countSharedClonotypes()` function to compute the Jaccard index for the number of shared clonotypes (weighted by the number of cells exhibiting each clonotype) between all pairs of T cell clusters.

```{r}
shared <- countSharedClonotypes(sce.pbmc$TRA,
    clone.field="raw_clonotype_id",
    cov.field="umis",
    group=sce.pbmc$cluster)

# Only caring about the TCR-expressing clusters:
shared[has.tcr,has.tcr]
```

```{r, echo=FALSE}
first.sharing <- '2'
second.sharing <- '16'
stopifnot(identical(first.sharing, greedy.bastard))
stopifnot(shared[second.sharing,first.sharing] > 40)
```

We see that clusters `r first.sharing` and `r second.sharing` contain quite a few cells that share a clonotype.
This is potentially interesting as it provides some evidence that the two cell subtypes (for which the clusters are proxies) originated from the same underlying population.
Indeed, further investigation indicates that this sharing is driven by clonal expansion within cluster `r greedy.bastard`, suggesting that there was a change in cell state upon activation and proliferation for a subset of clones. 

```{r}
common <- intersect(names(clono.tra[["2"]]), names(clono.tra[["16"]]))
clono.tra[["2"]][common]
clono.tra[["16"]][common]
```

```{r, echo=FALSE}
# Checking that the above result is what we expected it to be.
stopifnot(identical(
    intersect(names(clono.tra[["2"]]), names(clono.tra[["16"]])),
    intersect(names(clono.tra[[first.sharing]]), names(clono.tra[[second.sharing]]))
))
```

Of course, the relevance of this result depends on whether the two clusters actually represent distinct cell subtypes.
Some sharing is to be expected between neighboring clusters where a few cells of a clonotype in one cluster may be inadvertently assigned to another cluster.
In fact, given the general ambiguity of clustering, it may be advisable to verify that the difference between clusters persist in the subset of cells with shared clonotypes, e.g., by checking that the relevant marker genes are DE with `findMarkers()` (Chapter \@ref(marker-detection)).

```{r}
is.shared <- any(sce.pbmc$TRA[,"raw_clonotype_id"] %in% common)
sce.sub <- sce.pbmc[,is.shared]

library(scran)
marker.out <- findMarkers(sce.sub, sce.sub$cluster,
    restrict=c("2", "16"), direction="up", test.type="wilcox")
```

### Combining with the $\beta$ chain

The analysis above has focused on the $\alpha$ chain, but it is straightforward to repeat the steps on data for the $\beta$ chain.
We will omit this for brevity as it simply involves replacing `sce.pbmc$TRA` with `sce.pbmc$TRB` in each of the above functions.

Instead, here we will demonstrate how to analyze both chains together.
This is probably more important than the analysis of each chain in isolation,
given that both chains are required to form the TCR for binding to peptide-MHC complexes.
The first step is to collapse the data for each chain into a `DataFrame` with one row per cell;
we do so by selecting the most abundant sequence per cell with the `createPerCellDataFrame()` function.

```{r}
per.cell.A <- createPerCellDataFrame(sce.pbmc$TRA) 
nrow(per.cell.A)
per.cell.B <- createPerCellDataFrame(sce.pbmc$TRB)
nrow(per.cell.B)
```

It is then trivial to `cbind()` the two `DataFrame`s together to combine information from both chains for each cell.
We prefix the column names with `A` or `B` in the `cbind()` call in order to distinguish between fields for the different chains.

```{r}
per.cell.tcr <- cbind(A=per.cell.A, B=per.cell.B)
colnames(per.cell.tcr)
```

Once we have this combined `DataFrame`, we can re-use the same functions for counting gene combinations.
In this case, `countCellsPerGeneCombo()` will automatically ignore cells without both chains,
allowing us to directly use the output in functions like `testGeneComboCountsPairwise()`.

```{r}
v.combined <- countCellsPerGeneCombo(per.cell.tcr,
    gene.field=c("A.v_gene", "B.v_gene"),
    group=sce.pbmc$cluster)
head(assay(v.combined))
```

For the clonotype analysis, there is little benefit from using `per.cell.tcr` as the definition of the clonotypes is already based on information from both chains.
Clonotypes are typically defined based on identity in the $\beta$ chains, either in the complementarity determining region (CDR, typically CDR3) only or across the entire sequence.
The $\beta$ chain is used because the combinatorial space of possible sequences is larger than that for the $\alpha$ chain, thus providing finer discrimination between different clones.
If available, the $\alpha$ chain is used only as a "tie-breaker" if the $\beta$ chain sequences match between two cells or as a fallback if the $\beta$ chains are not available.
Regardless of the exact algorithm, this means that the clonotype calls will be the same in both chains for all cells that have sequences for both chains.
As such, it is often sufficient to perform the clonotype analysis on `sce.pbmc$TRB`, given that this is the main source of data used to define the clonotypes in the first place.

```{r}
# Demonstrating that the clonotype calls are, in fact, the same.
clonotype.A <- per.cell.tcr$A.raw_clonotype_id
clonotype.B <- per.cell.tcr$B.raw_clonotype_id
has.both <- !is.na(clonotype.A) & !is.na(clonotype.B)
identical(clonotype.A[has.both], clonotype.B[has.both])
```

```{r, echo=FALSE}
stopifnot(identical(clonotype.A[has.both], clonotype.B[has.both]))
```

## Analyzing the immunoglobulin repertoire

### Data processing

We obtain the immunoglobulin contig annotations for the same set of cells.
This follows a similar format to the TCR annotations and can be processed in the same manner.

```{r}
library(BiocFileCache)
bfc <- BiocFileCache(ask=FALSE)
ig.data <- bfcrpath(bfc, file.path(
    "http://cf.10xgenomics.com/samples/cell-vdj/3.1.0",
    "vdj_v1_hs_pbmc3/vdj_v1_hs_pbmc3_b_filtered_contig_annotations.csv"))
ig <- read.csv(ig.data, stringsAsFactors=FALSE)
nrow(ig)
head(ig)
```

The main difference from TCRs is that there are a few more chains,
namely the heavy chain (IGH) and the two light chains (IGL and IGK(.
This simply requires us to repeat the `splitDataFrameByCell()` calls a few times to create more `SplitDataFrameList`s.

```{r}
sce.pbmc$IGH <- splitDataFrameByCell(ig[ig$chain=="IGH",],
    field="barcode", universe=sce.pbmc$Barcode)
sce.pbmc$IGL <- splitDataFrameByCell(ig[ig$chain=="IGL",],
    field="barcode", universe=sce.pbmc$Barcode)
sce.pbmc$IGK <- splitDataFrameByCell(ig[ig$chain=="IGK",],
    field="barcode", universe=sce.pbmc$Barcode)
```

### Basic analysis

Everything described previously for TCRs can be repeated verbatim for the immunoglobulins.
For example, we can count the number of cells with any or multiple IGH sequences to identify clusters that likely contain B cells (Figure \@ref(fig:igh-prop-cluster)).

```{r igh-prop-cluster, fig.width=10, fig.wide=TRUE, fig.cap="Proportion of cells in each cluster that express IGH sequences in the PBMC dataset."}
props <- summarizeSequenceStatus(sce.pbmc$IGH, group=sce.pbmc$cluster)

tmp <- melt(as.matrix(props))
colnames(tmp) <- c("Cluster", "Type", "Proportion")
tmp$Cluster <- factor(tmp$Cluster)

ggplot(tmp, aes(x=Cluster, y=Proportion, fill=factor(Type))) +
    geom_bar(stat="identity", position="dodge", colour="black") +
    scale_fill_brewer(type="qual", palette=1)
```

We can count the number of cells exhibiting each combination of genes and test for differences in gene usage between clusters.
In this case, we do not have many distinct B cell clusters and they do not exhibit clear differences in IgH gene usage.

```{r}
se.igh <- countCellsPerGeneCombo(sce.pbmc$IGH,
    gene.field=c("v_gene", "j_gene", "d_gene"),
    cov.field="umis",
    group=sce.pbmc$cluster)

has.igh <- colSums(assay(se.igh)) >= 40
heavy.test <- testGeneComboCountsPairwise(se.igh[,has.igh])

# Counting the number of DE genes in each pairwise comparison.
has.de <- lapply(heavy.test, FUN=function(x) sum(x$FDR<=0.05))
has.de
```

```{r, echo=FALSE}
stopifnot(all(unlist(has.de)==0L))
```

Similarly, we can quantify clonal expansion using the `summarizeClonotypeCounts()` function.
Here, we observe practically no clonal expansion in any of the B cell clusters -
for example, a Gini index of 1 indicates that all cells have the same count (after downsampling) -
suggesting that the B cells are not participating in any immune response in this dataset.

```{r}
clono.igh <- countCellsPerClonotype(sce.pbmc$IGH,
    clone.field="raw_clonotype_id",
    cov.field="umis",
    group=sce.pbmc$cluster)

set.seed(10010)
clono.out <- summarizeClonotypeCounts(clono.igh[has.igh])
clono.out
```

```{r, echo=FALSE}
stopifnot(all(clono.out$gini >= 0.95))
```

### Lineage analyses

The major difference for immunoglobulins compared to TCRs is that the former undergoes somatic hypermutation in its CDRs.
This means that, for a given clonotype, it is possible to construct lineage trees involving the member cells.
Examination of this tree provides some insight into the history of that clonotype;
this becomes especially interesting when combined with single-cell resolution of 
as we can identify trees that contain members at different stages of maturity (e.g., naive B cells, memory B cells, plasmablasts).

```{r}
# TODO: need a demonstration B cell dataset 
# with lots of clonal expansion.
```

## Multi-sample analyses

A much more interesting analysis is possible when there are multiple samples and treatment conditions, where the aim is to determine which clusters contain T cell clonotypes that expand in response to treatment.
In much the same vein as the analysis in Chapter \@ref(multi-sample-comparisons), we can obtain a cluster-by-sample count matrix by simply `cbind()`ing together the `tra.counts.clonal` vector from each sample.
To demonstrate, we will pretend that our cells are derived from 4 samples that have been merged together for common clustering (Chapter \@ref(integrating-datasets)).

```{r}
pretend.samples <- sample(letters[1:4], ncol(sce.pbmc), replace=TRUE)

# Creating a count matrix.
clone.counts <- any.counts <- list()
for (i in sort(unique(pretend.samples))) {
    current.sample <- sce.pbmc[,i==pretend.samples]
    clone.id.A <- unlist(unique(current.sample$TRA[,"raw_clonotype_id"]))
    expanded.id.A <- setdiff(clone.id.A[duplicated(clone.id.A)], "None")
    is.clone.A <- any(current.sample$TRA[,"raw_clonotype_id"] %in% expanded.id.A)
    clone.counts[[i]] <- table(current.sample$cluster[is.clone.A])
    any.counts[[i]] <- table(current.sample$cluster[lengths(current.sample$TRA) > 0])
}

clone.counts <- do.call(cbind, clone.counts)
any.counts <- do.call(cbind, any.counts)
```

We then test for condition-specific differences in the proportion of clonotypes that are expanded.
A natural approach would be to apply a beta-binomial model to each cluster, using the expanded and TCR-containing counts as input; for the time being, though, we will just perform a simple Wilcoxon ranked sum test.
We test on proportions to accommodate biological differences in T cell abundance between samples well as technical differences in, say, sequencing depth that might affect the success rate of TCR calls on a sample-by-sample basis.

```{r}
prop <- clone.counts/any.counts

# Pretending that the first two samples are cases,
# and the second two samples are controls.
wilcox.test(prop[tclust.1,1:2], prop[tclust.1,3:4])
wilcox.test(prop[tclust.2,1:2], prop[tclust.2,3:4])
```

## Session Info {-}

```{r sessionInfo, echo=FALSE, results='asis'}
prettySessionInfo()
```
