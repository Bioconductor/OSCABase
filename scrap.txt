Extra junk from data integration step. Saved for now until it can be rewritten.

## Harmony

Harmony provides a unified framework for data visualization, analysis, and interpretation of scRNA-seq data. Included is a method for integrating different batches of scRNA-seq. This produces a new dimension reduction representation, saved as `HARMONY` within the *SingleCellExperiment* object, as shown below. Furthermore, this Harmony embedding can be used to produce a UMAP representation as well:

```{r}
## Combine pbmc3k and pbmc4k datasets into single sce
## Removing mcols needed to let cbind work
p3 <- pbmc3k
p4 <- pbmc4k
mcols(p3) <- mcols(p3)[, -1:-ncol(mcols(p3))]
mcols(p4) <- mcols(p4)[, -1:-ncol(mcols(p4))]
int <- intersect(rownames(p3), rownames(p4))
sce <- cbind(p3[int, ], p4[int, ])
chosen.hvgs <- chosen.hvgs[chosen.hvgs %in% int]
```

```{r}
library(harmony) # devtools::install_github('immunogenomics/harmony')
library(BiocSingular)

## create a new sce for harmony
sce_harmony <- sce

## Add PCA to sce, then run Harmony as its dependent on PCA
sce_harmony <- runPCA(sce_harmony,
                      feature_set = chosen.hvgs,
                      BSPARAM = BiocSingular::RandomParam(),
                      BPPARAM = BiocParallel::MulticoreParam())
sce_harmony <- RunHarmony(sce_harmony, group.by.vars = "Sample")

## Calculate UMAP on Harmony embeddings
sce_harmony <- runUMAP(sce_harmony, use_dimred = 'HARMONY')
```


```{r, fig.cap = 'Plot of the first two components of the Harmony embedding (left). UMAP calculated on the Harmony embeddings. (right)'}
p1 <- plotReducedDim(sce_harmony, 'HARMONY', colour_by = 'Sample')
p2 <- plotReducedDim(sce_harmony, 'UMAP', colour_by = 'Sample')
wrap_plots(p1, p2, nrow = 1)
```


## Advanced MNN Workflow

Here we work through a more advanced workflow using MNN as above, but this time walking through the various steps that are otherwise implicit within the `fastMNN()` function. While not always necessary, it may be informative for those interested in the finer details of a batch correction workflow. Note that this follows the 

For more details, we refer to the [`compareSingleCell` vignette](https://github.com/MarioniLab/compareSingleCell/) vignette by Aaron Lun.

<!-- ### Feature Selection -->

<!-- We briefly highlight feature selection within the preprocessing, as the choice of genes used in the integration can have an outsize effect on end result.  -->

<!-- For brevity, here we use the `scran` package to identify the genes with biological coefficients of variation greater than zero, but leave the choice of method up to the reader. Note that, compared to the basic analysis workflow, we use the `multiBlockVar()` function and block on the origin (`pbmc3k` vs `pbmc4k`). This function models the variance of expression in each block separately. -->

<!-- Additionally, we turn off weighting such that each sample contributes equally to the results, regardless of the number of cells per sample. This prevents one condition from biasing the combined statistics.  -->

<!-- For more details, we refer to the [`compareSingleCell` merge](https://github.com/MarioniLab/compareSingleCell/blob/master/vignettes/embryo_merge.Rmd) vignette. -->


```{r}
## create a new sce for advanced mnn
sce_mnn_advanced <- sce
```

<!-- ```{r} -->
<!-- library(scran) -->
<!-- dec <- multiBlockVar(sce_mnn_advanced, block = sce_mnn_advanced$Sample, -->
<!--                      make.tech.trend = TRUE, -->
<!--                      weighted = FALSE) -->

<!-- hvg <- rownames(dec)[dec$bio > 0] -->
<!-- ``` -->

<!-- In this example, we get back `r sum(dec$bio > 0)` genes. -->


<!-- ```{r} -->
<!-- hvg_subset <- hvg[1:1000] -->
<!-- ``` -->

### Dimensionality Reduction

Principal components analyses can be used to both reduce computational work and remove high-dimensional noise, as discussed in the `r Biocpkg("simpleSingleCell", "reads.html#denoising-expression-values-using-pca", "simpleSingleCell vignette")`. 

To accomplish this, the `multiBatchPCA()` function from *scran* ensures that each sample contributes equally to the new coordinate space. For further discussion on this point, see the `r Biocpkg("simpleSingleCell", "batch.html#hierarchical-merging", "simpleSingleCell vignette")` section on hierarchical merging.

We then calculate the number of PCs to retain by comparing the variance explained per principal component versus the technical noise and total variance in the data. This will leave us with a subset of PCA components.

Note that we will use the features selected from the preproprocessing step earlier in this chapter.


```{r}
library(batchelor)
library(BiocSingular) # provide approximate pca via RandomParam()

## Calculate PCA by batch
set.seed(1234) # for Random/RandomParam backends

## run batchelor version of multiBatchPCA (use :: notation to override namespace)
pcs <- batchelor::multiBatchPCA(sce_mnn_advanced,
                                batch = sce_mnn_advanced$Sample,
                                subset.row = chosen.hvgs,
                                get.variance = TRUE,
                                BSPARAM = BiocSingular::RandomParam(),
                                BPPARAM = BiocParallel::MulticoreParam())

## Retain only the top PCs based on variance explained > technical noise
retain <- denoisePCANumber(
    metadata(pcs)$var.explained, # variance explained per PC.
    sum(dec[chosen.hvgs, ]$tech),       # technical noise in subset of genes.
    metadata(pcs)$var.total      # total variance in the data
)

retain
```

From the number of PCs to retain, we can filter the PCs as follows:

```{r}
## Subset PCA number of components up to the number in retain
top_pcs <- map(as.list(pcs), ~ .[, 1:retain])
```

Then, using the retained components as input, we can input them directly into the `fastMNN()` method as follows, and furthermore produce a UMAP representation based on these MNN coordinates:

```{r}
## Calculate MNN coordinates, add into reducedDims
mnn_advanced_out <- batchelor::fastMNN(top_pcs$pbmc3k,
                                       top_pcs$pbmc4k,
                                       pc.input = TRUE)
reducedDim(sce_mnn_advanced, 'MNN') <- mnn_advanced_out$corrected

## Run UMAP on MNN coordinates
sce_mnn_advanced <- runUMAP(sce_mnn_advanced, use_dimred = 'MNN')
```

The MNN coordinates and the UMAP coordinates derived from them are visualized below:

```{r, fig.cap = "Plot of first two MNN coordinates (left). UMAP calculated on the MNN coordinates (right). Colour denotes origin of sample."} 
p1 <- plotReducedDim(sce_mnn_advanced, 'MNN', colour_by = 'Sample')
p2 <- plotReducedDim(sce_mnn_advanced, 'UMAP', colour_by = 'Sample')
wrap_plots(p1, p2, nrow = 1)
```

Comparing to the simpler MNN workflow shown above (which only used the `fastMNN()` function on the barely processed *SingleCellExperiment* class object `sce`), we see that the two results are fairly comparable, differing only by the number of principal components and the selected number of features (here we chose 1000 for computational efficacy; we leave it to the interested reader to explore the results with a larger feature space).


## Naive Method Without Correction

For completeness, we show here the results of performing the correction solely on the gene expression matrix.

```{r}
## create a new sce for naive method
sce_naive <- sce
```

```{r}
## run PCA on only the normalized gene expression data
sce_naive <- runPCA(sce_naive,
                    feature_set = chosen.hvgs,
                    BSPARAM = BiocSingular::RandomParam(),
                    BPPARAM = BiocParallel::MulticoreParam())

## Run UMAP on the norm gene exp. derived PCA coordinates - use only top PCs
sce_naive <- runUMAP(sce_naive, use_dimred = 'PCA')

```

```{r, fig.cap = "First two components of PCA calculated directly from the gene expression matrix (left). UMAP calculated on the PCA derived from the normalized gene expression matrix (right)."}
p1 <- plotPCA(sce_naive, colour_by = 'Sample')
p2 <- plotReducedDim(sce_naive, 'UMAP', colour_by = 'Sample')
wrap_plots(p1, p2, nrow = 1)
```

While the PCA looks well integrated, the UMAP representation - which encapsulates a fuller PCA space - distinctly shows the residual batch effect present.


## Limma Batch Correction

The `limma` package, a popular framework for the statistical analysis of RNA-seq, has a function `removeBatchEffect()` which will be used here to correct the normalized expression matrix `logcounts` across the two batches. The result will be assigned into the `assays` slot of the `sce` object as `limma_corrected`, and then used for PCA, saving the result in the `reducedDim` slot as `"PCA_limma"`.

```{r}
## create a new sce for limma method
sce_limma <- sce
```

```{r}
library(limma)
limma_corrected <- removeBatchEffect(logcounts(sce_limma), batch = sce_limma$Sample)
assay(sce_limma, "logcounts_limma") <- limma_corrected ## add new assay

## calc a PCA on limma values; save separate to prevent overwriting
sce_limma <- runPCA(sce_limma,
                    feature_set = chosen.hvgs,
                    exprs_values = "logcounts_limma",
                    BSPARAM = BiocSingular::RandomParam(),
                    BPPARAM = BiocParallel::MulticoreParam())

## run UMAP; save separate to prevent overwriting
sce_limma <- runUMAP(sce_limma, use_dimred = 'PCA')
```

The resulting PCA and UMAP from the limma batch correction method are shown below:

```{r, fig.cap = 'PCA calculated on the limma batch-corrected gene expression matrix (left). UMAP calculated via the PCA derived from limma batch-corrected gene expression matrix (right).'}
p1 <- plotReducedDim(sce_limma, 'PCA', colour_by = 'Sample')
p2 <- plotReducedDim(sce_limma, 'UMAP', colour_by = 'Sample')
wrap_plots(p1, p2, nrow = 1)
```
